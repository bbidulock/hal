<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>HAL 0.4.6.cvs20050121 Specification</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"></HEAD
><BODY
CLASS="book"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="BOOK"
><A
NAME="index"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="title"
><A
NAME="AEN2"
>HAL 0.4.6.cvs20050121 Specification</A
></H1
><H3
CLASS="author"
><A
NAME="AEN7"
></A
>David Zeuthen</H3
><DIV
CLASS="affiliation"
><DIV
CLASS="address"
><P
CLASS="address"
><br>
	&nbsp;&nbsp;&nbsp;&nbsp;<CODE
CLASS="email"
>&#60;<A
HREF="mailto:david@fubar.dk"
>david@fubar.dk</A
>&#62;</CODE
><br>
	&nbsp;&nbsp;</P
></DIV
></DIV
><SPAN
CLASS="releaseinfo"
>Version 0.4.6.cvs20050121<BR></SPAN
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="#introduction"
>Introduction</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN15"
>About</A
></DT
><DT
><A
HREF="#AEN24"
>Document History</A
></DT
><DT
><A
HREF="#AEN46"
>Acknowledgements</A
></DT
></DL
></DD
><DT
><A
HREF="#overview"
>Overview</A
></DT
><DD
><DL
><DT
><A
HREF="#ov_halarch"
>Architecture of HAL</A
></DT
><DT
><A
HREF="#ov_hal_linux26"
>HAL on Linux 2.6</A
></DT
></DL
></DD
><DT
><A
HREF="#AEN108"
>Device Objects</A
></DT
><DT
><A
HREF="#device-capabilities"
>Device Capabilities</A
></DT
><DT
><A
HREF="#using-devices"
>Using devices</A
></DT
><DT
><A
HREF="#device-properties"
>Device Properties</A
></DT
><DD
><DL
><DT
><A
HREF="#properties-metadata"
>Metadata Properties</A
></DT
><DD
><DL
><DT
><A
HREF="#device-properties-info"
><TT
CLASS="literal"
>info</TT
> namespace</A
></DT
><DT
><A
HREF="#device-properties-linux"
><TT
CLASS="literal"
>linux</TT
> namespace</A
></DT
></DL
></DD
><DT
><A
HREF="#properties-bus"
>Physical Properties</A
></DT
><DD
><DL
><DT
><A
HREF="#device-properties-pci"
><TT
CLASS="literal"
>pci</TT
> namespace</A
></DT
><DT
><A
HREF="#device-properties-usb"
><TT
CLASS="literal"
>usb_device</TT
> namespace</A
></DT
><DT
><A
HREF="#device-properties-usbif"
><TT
CLASS="literal"
>usb</TT
> namespace</A
></DT
><DT
><A
HREF="#device-properties-ide-host"
><TT
CLASS="literal"
>ide_host</TT
> namespace</A
></DT
><DT
><A
HREF="#device-properties-ide"
><TT
CLASS="literal"
>ide</TT
> namespace</A
></DT
><DT
><A
HREF="#device-properties-scsi_host"
><TT
CLASS="literal"
>scsi_host</TT
> namespace</A
></DT
><DT
><A
HREF="#device-properties-scsi"
><TT
CLASS="literal"
>scsi</TT
> namespace</A
></DT
><DT
><A
HREF="#device-properties-ieee1394_host"
><TT
CLASS="literal"
>ieee1394_host</TT
> namespace</A
></DT
><DT
><A
HREF="#device-properties-ieee1394_node"
><TT
CLASS="literal"
>ieee1394_node</TT
> namespace</A
></DT
><DT
><A
HREF="#device-properties-ieee1394"
><TT
CLASS="literal"
>ieee1394</TT
> namespace</A
></DT
><DT
><A
HREF="#device-properties-block"
><TT
CLASS="literal"
>block</TT
> namespace</A
></DT
></DL
></DD
><DT
><A
HREF="#properties-functional"
>Functional Properties</A
></DT
><DD
><DL
><DT
><A
HREF="#device-properties-volume"
><TT
CLASS="literal"
>volume</TT
> namespace</A
></DT
><DT
><A
HREF="#device-properties-kernel"
><TT
CLASS="literal"
>kernel</TT
> namespace</A
></DT
><DT
><A
HREF="#device-properties-volume-disc"
><TT
CLASS="literal"
>volume.disc</TT
> namespace</A
></DT
><DT
><A
HREF="#device-properties-storage"
><TT
CLASS="literal"
>storage</TT
> namespace</A
></DT
><DT
><A
HREF="#device-properties-storage-cdrom"
><TT
CLASS="literal"
>storage.cdrom</TT
> namespace</A
></DT
><DT
><A
HREF="#device-properties-net"
><TT
CLASS="literal"
>net</TT
> namespace</A
></DT
><DT
><A
HREF="#device-properties-net-80203"
><TT
CLASS="literal"
>net.80203</TT
> namespace</A
></DT
><DT
><A
HREF="#device-properties-net-80211"
><TT
CLASS="literal"
>net.80211</TT
> namespace</A
></DT
><DT
><A
HREF="#device-properties-input"
><TT
CLASS="literal"
>input</TT
> namespace</A
></DT
><DT
><A
HREF="#device-properties-pcmcia_socket"
><TT
CLASS="literal"
>pcmcia_socket namespace</TT
></A
></DT
><DT
><A
HREF="#device-properties-printer"
><TT
CLASS="literal"
>printer</TT
> namespace</A
></DT
><DT
><A
HREF="#device-properties-portable_audio_player"
><TT
CLASS="literal"
>portable_audio_player</TT
> namespace</A
></DT
><DT
><A
HREF="#device-properties-camera"
><TT
CLASS="literal"
>camera</TT
> namespace</A
></DT
></DL
></DD
><DT
><A
HREF="#properties-policy"
>Policy Properties</A
></DT
><DD
><DL
><DT
><A
HREF="#device-properties-storage-policy-default"
><TT
CLASS="literal"
>storage.policy.default</TT
> namespace</A
></DT
><DT
><A
HREF="#device-properties-storage-policy"
><TT
CLASS="literal"
>storage.policy</TT
> namespace</A
></DT
><DT
><A
HREF="#device-properties-volume-policy"
><TT
CLASS="literal"
>volume.policy</TT
> namespace</A
></DT
></DL
></DD
></DL
></DD
><DT
><A
HREF="#spec-device-info"
>Device Information Files</A
></DT
><DD
><DL
><DT
><A
HREF="#fdi-facts"
>Facts about devices</A
></DT
><DD
><DL
><DT
><A
HREF="#fdi-example-mp3player"
>Example: MP3 player</A
></DT
><DT
><A
HREF="#fdi-example-camera"
>Example: Digital Still Camera</A
></DT
><DT
><A
HREF="#fdi-example-6in1"
>Example: Card Reader</A
></DT
></DL
></DD
><DT
><A
HREF="#fdi-policy"
>Policy settings for devices</A
></DT
><DD
><DL
><DT
><A
HREF="#fdi-example-mountsetting"
>Storage Devices</A
></DT
></DL
></DD
></DL
></DD
><DT
><A
HREF="#callouts"
>Callouts</A
></DT
><DT
><A
HREF="#dbus-api"
>D-BUS Network API</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN2141"
>Interface org.freedesktop.Hal.Manager</A
></DT
><DD
><DL
><DT
><A
HREF="#AEN2152"
>Example</A
></DT
></DL
></DD
><DT
><A
HREF="#AEN2160"
>Interface org.freedesktop.Hal.Device</A
></DT
></DL
></DD
><DT
><A
HREF="#enforcing-policy"
>Enforcing Policy</A
></DT
><DD
><DL
><DT
><A
HREF="#enforcing-stor-vol"
>Storage Devices</A
></DT
><DD
><DL
><DT
><A
HREF="#stor-vol-policy"
>Policy for Volumes and Storage devices</A
></DT
><DT
><A
HREF="#enforcing-storage-fstab"
>File systems file</A
></DT
><DT
><A
HREF="#enforcing-storage-locking"
>Disabling policy agents</A
></DT
></DL
></DD
></DL
></DD
></DL
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="introduction"
></A
>Introduction</H1
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
NAME="AEN15"
>About</A
></H2
><P
>&#13;	This document concerns the specification of HAL which is a
	piece of software that provides a view of the various hardware
	attached to a system. In addition to this, HAL keeps detailed
	metadata for each piece of hardware and provide hooks such
	that system- and desktop-level software can react to changes
	in the hardware configuration in order to maintain system
	policy.

      </P
><P
>&#13;
	HAL represents a piece of hardware as a 
	<I
CLASS="emphasis"
>device object</I
>. A device object is
	identified by a unique identifer and carries a set of
	key/value paris referred to as <I
CLASS="emphasis"
>device
	properties</I
>. Some properties are derived from the
	actual hardware, some are merged from <I
CLASS="emphasis"
>device
	information files</I
> and some are related to the
	actual device configuration. This document specifies the set
	of device properties and gives them well-defined meaning. This
	enable system and desktop level components to distinguish
	between the different device objects and discover and
	configure devices based on these properties.

      </P
><P
>&#13;	
	HAL provides an easy-to-use API through D-BUS which is an IPC
	framework that, among other things, provides a system-wide
	message-bus that allows applications to talk to one
	another. Specifically, D-BUS provides asynchronous
	notification such that HAL can notify other peers on the
	message-bus when devices are added and removed as well as when
	properties on a device are changing.  

      </P
><P
>&#13;
	The most important goal of HAL is to provide plug-and-play
	facilities for UNIX-like desktops with focus on providing a
	rich and extensible description of device characteristics and
	features. HAL has no other major dependencies apart from D-BUS
	which, given sufficient infrastructure, allows it to be
	implemented on many UNIX-like systems. The major focus,
	initially, is systems running the Linux 2.6 series kernels.

      </P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="AEN24"
>Document History</A
></H2
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN26"
></A
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Version</TH
><TH
>Date</TH
><TH
>Comment</TH
></TR
></THEAD
><TBODY
><TR
><TD
>0.1</TD
><TD
>September 28, 2003</TD
><TD
>Still important things missing. Released with version
                     0.1 of the implementation</TD
></TR
><TR
><TD
>0.2</TD
><TD
>December 22, 2003</TD
><TD
>A major rewrite.</TD
></TR
><TR
><TD
>0.4.6.cvs20050121</TD
><TD
>&nbsp;</TD
><TD
>Current draft from CVS</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="AEN46"
>Acknowledgements</A
></H2
><P
>&#13;
      Havoc Pennington's article
      <A
HREF="http://www.ometer.com/hardware.html"
TARGET="_top"
>''Making
      Hardware Just Work''</A
> motivated this
      work. The specification and software would not exist
      without all the useful ideas, suggestions, comments and patches
      from the 
      <A
HREF="http://freedesktop.org/mailman/listinfo/xdg"
TARGET="_top"
>Free Desktop</A
> and
      <A
HREF="http://freedesktop.org/mailman/listinfo/hal"
TARGET="_top"
>HAL</A
>
      mailing lists.

      </P
><P
>&#13;
      All trademarks mentioned belong to their respective owners.

      </P
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="overview"
></A
>Overview</H1
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
NAME="ov_halarch"
>Architecture of HAL</A
></H2
><P
>&#13;
      The HAL consists of a number of components as outlined in the
      diagram below. Note that this diagram is high-level and doesn't
      capture implementation details.

    </P
><P
>&#13;      <IMG
SRC="hal-arch.png">
    </P
><P
>&#13;
      Details on each component

      <P
></P
><UL
><LI
><P
>&#13;          <I
CLASS="emphasis"
>HAL daemon</I
></P
><P
> 

          A system-wide daemon that maintains a persistent database of
          device objects. The daemon is also responsible for merging
          information from the device information file repository and
          managing the life cycle of device objects. The HAL daemon
          also contains detection and monitoring code for
          buses (such as PCI and USB buses) and devices (such as
          networking and storage devices). The HAL daemon notifies system
          level components through callouts and session level
          components using the D-BUS interface.

        </P
></LI
><LI
><P
>&#13;          <I
CLASS="emphasis"
>Applications</I
></P
><P
> 

            This represents the end consumers of the HAL and comprises
            both applications that need to search for a device, but
            also (existing) device specific libraries and/or services
            that provide access to devices. Specifically, the
            application or device library can obtain the ''address''
            (the special device file or other details), of the device
            through HAL, to interact with the device through the
            kernel as usual.

          </P
><P
>&#13;
            In addition, this group include desktop environments such
            as GNOME or KDE. Specifically, using HAL, desktop
            environments may include session-level daemons enforcing
            certain policies when the device database managed by the
            HAL daemon changes. Such policies may include starting a
            photo management application when a camera is plugged in,
            assisting the user in finding driver software and device
            information files for a new device, displaying link status
            information about network devices, mounting removable
            storage and so on.

          </P
><P
>&#13;
	    Note that several desktop sessions may be active on the
	    same system; it is the responsibility of session-level
	    software to arbitrate the device access between sessions.

        </P
></LI
><LI
><P
>&#13;          <I
CLASS="emphasis"
>Callouts</I
></P
><P
> 

	    Callouts are programs invoked when the device object list
	    is modified or when a device property changes. As such, callouts
	    can be used to maintain system-wide policy (that may be
	    specific to the particular OS) such as changing
	    permissions on device nodes, updating the
	    systemwide <TT
CLASS="literal"
>/etc/fstab</TT
> file or
	    configuring the networking subsystem.

        </P
></LI
></UL
>
      </P
><P
>&#13;
      The HAL uses D-BUS to provide a ''network API'' to
      applications. As D-BUS is designed to be language independent,
      potentially many languages / runtime systems will be able to
      easily access the services offered by HAL. The D-BUS API is
      detailed in <A
HREF="#dbus-api"
>the Chapter called <I
>D-BUS Network API</I
></A
>. Note that HAL doesn't
      enforce any policy at all, this is left for desktop environments
      and operating systems vendors to implement.  However, to ensure
      interoperability between operating systems and desktop
      environments, recommendations and best practises on how to
      enforce policy is discussed in <A
HREF="#enforcing-policy"
>the Chapter called <I
>Enforcing Policy</I
></A
>.

    </P
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="ov_hal_linux26"
>HAL on Linux 2.6</A
></H2
><P
>&#13;
      On a Linux 2.6 system HAL is implemented as shown in the diagram
      below:

      </P
><P
>&#13;	<IMG
SRC="hal-linux26.png">
      </P
><P
>&#13;
      Highlights

      <P
></P
><UL
><LI
><P
>&#13;	    HAL depends on the <TT
CLASS="literal"
>udev</TT
> and 
	    <TT
CLASS="literal"
>linux-hotplug</TT
> packages
        </P
></LI
><LI
><P
>&#13;	    The diagram shows an example callout program, 
	    <TT
CLASS="literal"
>fstab-sync</TT
>, that creates/destroys
	    mount points and modifies the <TT
CLASS="literal"
>/etc/fstab</TT
>
	    file accordingly whenever storage devices are added or
	    removed.
        </P
></LI
><LI
><P
>&#13;	    A session-level daemon, <TT
CLASS="literal"
>*-volume-manager</TT
>,
	    for mounting storage devices is shown. This piece of software
	    depends on a properly updated <TT
CLASS="literal"
>/etc/fstab</TT
>
	    file and a setuid <TT
CLASS="literal"
>mount(1)</TT
> binary that 
	    allows an unprivileged user to mount devices marked with option
	    <TT
CLASS="literal"
>user</TT
> in the <TT
CLASS="literal"
>/etc/fstab</TT
> file.
        </P
></LI
><LI
><P
>&#13;	    The <TT
CLASS="literal"
>fstab-sync</TT
> and 
	    <TT
CLASS="literal"
>*-volume-manager</TT
> programs are only
	    examples on how to enforce policy and are not part of HAL
	    proper.  An OS vendor may choose to enforce policy in a
	    different way e.g. he might want to ignore the 
	    <TT
CLASS="literal"
>/etc/fstab</TT
> file and mount storage volumes
	    in the callout, run a daemon with sufficient privileges
	    or use another setuid mount wrapper.
	    See <A
HREF="#enforcing-policy"
>the Chapter called <I
>Enforcing Policy</I
></A
> for more details.
        </P
></LI
></UL
>

    </P
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="AEN108"
></A
>Device Objects</H1
><P
>&#13;
	It is important to precisely define the term HAL device
	object. It's actually a bit blurry to define in general, it
	includes what most UNIX-like systems consider first class
	objects when it comes to hardware. In particular, a device
	object should represent the smallest unit of addressable
	hardware. This means there can be a one-to-many relationship
	between a physical device and the device objects exported by
	HAL. Specifically, a multi-function printer, which appear to
	users as a single device may show up as several device
	objects; e.g. one HAL device object for each of the printing,
	scanning, fax and storage interfaces. Conversely, some devices
	may be implemented such that the HAL device object represent
	several functional interfaces. HAL is not concerned with this
	duality of either one-to-many or many-to-one relationships
	between device objects and the actual iron constituting what
	users normally understand as a single piece of hardware;
	a device object represents the smallest addressable unit.

      </P
><P
>&#13;
	Device objects in HAL are organised on a by-connection basis,
	e.g. for a given device object X it is possible to find the
	device object Y where X is attached to Y. This gives structure
	to the device database of HAL; it is possible to map the
	devices out in a tree. Further, software emulation devices
	exported by a kernel, such as SCSI emulation for USB Storage
	Devices, are also considered device objects in HAL. This
	implies that kernel specific bits leak into the device object
	database. However users of HAL won't notice, such device
	objects are not referenced anywhere in the device objects that
	users are interested in; they are merely used as glue to build
	the device tree.

      </P
><P
>&#13;
	In addition to provide information about what kind of hardware
	a device object represents (such as a PCI or USB device) and
	how to address it, HAL merges information about the functional
	interfaces the OS kernel provides in order to use the device;
	in most cases this is represented on the device object as a
	string property with the name of the special device file in
	<TT
CLASS="literal"
>/dev</TT
>. In addition to the special device
	file, a number of other useful properties are merged. This
	means that both hardware and functional properties are on the
	same device object, which is very useful for an application
	programmer. For example, an application might query HAL for
	the device object that exports the special device file
	<TT
CLASS="literal"
>/dev/input/mouse2</TT
> and learn that this is
	provide by an USB mouse from a certain manufacturer by
	checking the properties that export the USB vendor and product
	identifiers.  See <A
HREF="#device-capabilities"
>the Chapter called <I
>Device Capabilities</I
></A
> and
	<A
HREF="#device-properties"
>the Chapter called <I
>Device Properties</I
></A
> for details.

      </P
><P
>&#13;
	On a formal level, a device object is comprised by

      </P
><P
></P
><UL
><LI
><P
>&#13;
          <I
CLASS="emphasis"
>UDI</I
></P
><P
> 

          This is an identifier, the Unique Device Identifer, that is
          unique for a device object - that is, no other device object
          can have the same UDI at the same time.  The UDI is computed
          using bus-specific information and is meant to be unique
          across device insertions and independent of the physical
          port or slot the device may be plugged into.

        </P
></LI
><LI
><P
>&#13;
          <I
CLASS="emphasis"
>Properties</I
></P
><P
> 

          Each device object got a set of properties which are
          key/value pairs.  The key is an ASCII string while the value
          can be one of several types

          <P
></P
><UL
><LI
><P
><TT
CLASS="literal"
>string</TT
> - 
		UTF8 string</P
></LI
><LI
><P
><TT
CLASS="literal"
>int</TT
> - 
		32-bit signed integer</P
></LI
><LI
><P
><TT
CLASS="literal"
>uint64</TT
> - 
		64-bit unsigned integer</P
></LI
><LI
><P
><TT
CLASS="literal"
>bool</TT
> - 
		truth value</P
></LI
><LI
><P
><TT
CLASS="literal"
>double</TT
> - 
		IEEE754 double precision floating point number</P
></LI
></UL
>

        </P
></LI
></UL
><P
>&#13;	Properties of a device object carry all the important
	information about a device object. For organisational reasons
	properties are also namespaced using ''.'' as a separator.
	
      </P
><P
>&#13;
	It can be useful to classify properties into four groups

      </P
><P
></P
><UL
><LI
><P
>Metadata - Information about how the devices
	                are connected with respect to each other
	                (parent/child relationships), what kind of
	                device it is, what functionality it provides
	                etc.
	</P
></LI
><LI
><P
>Facts - 
                        vendor ID, product ID, disk serial numbers, 
	                number of buttons on a mouse, formats accepted
	                by a mp3 player and so on.</P
></LI
><LI
><P
>Usage specific information - 
	                Network link status, special device file name, 
                        filesystem mount location etc.</P
></LI
><LI
><P
>Policy - 
                        How the device is to be used be users; usually
	                defined by the system administrator.</P
></LI
></UL
><P
>&#13;
	The first category is determined by HAL, the next is merged
	from either the hardware itself or device information files,
	the third is intercepted by monitoring the operating system
	and the last is merged from files that only the system
	administrator can edit. This specification is concerned with
	precisely defining several properties; see <A
HREF="#device-properties"
>the Chapter called <I
>Device Properties</I
></A
> and onwards for more
	information.  As a complement to device properties, HAL also
	provides <I
CLASS="emphasis"
>conditions</I
> on HAL device
	objects. Conditions are used to relay events that are
	happening on devices which are not easily expressed in
	properties. This includes events such as ''processor is
	overheating'' or ''block device unmounted''.

      </P
><P
>&#13;
	There is a special hal device object referred to as the ''root
	computer device object''. This device object represent the
	entire system as a whole and all other devices are either
	directly or indirectly childs of this device object. It has
	the
	UDI <TT
CLASS="literal"
>/org/freedesktop/Hal/devices/computer</TT
>.

      </P
><P
>&#13;
	The fundamental idea about HAL is that all ''interesting''
	information about hardware that a desktop application needs,
	can be obtained by querying HAL. Below is a screenshot of a
	simple device manager application shipped with HAL
	called <TT
CLASS="literal"
>hal-device-manager</TT
>.  This
	application is communicating with the HAL daemon and displays
	the tree of device objects. The shown properties are for a
	device object representing a harddisk.
      </P
><P
>&#13;        <IMG
SRC="hal-devices1.png">
      </P
><P
>&#13;
      </P
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="device-capabilities"
></A
>Device Capabilities</H1
><P
>&#13;
       Mainstream hardware isn't very good at reporting what they are,
       they only report, at best, how to interact with them. This is a
       problem; many devices, such as MP3 players or digital still
       cameras, appear to the operating system as plain USB Mass
       Storage devices when they in fact are a lot more than just
       that. The core of the problem is that without external
       metadata, the operating system and desktop environment will
       present it to the user as just e.g. a mass storage device.

     </P
><P
>&#13;
       As HAL is concerned with merging of external metadata, through
       e.g. device information files, there needs to be some scheme on
       how to record what the device actually is. This is achieved by
       two textual properties, <TT
CLASS="literal"
>info.category</TT
> and
       <TT
CLASS="literal"
>info.capabilities</TT
>. The former describes
       <I
CLASS="emphasis"
>what the device is</I
> (as a single
       alphanumeric keyword) and the latter describes
       <I
CLASS="emphasis"
>what the device does</I
> (as a number of
       alphanumeric keywords separated by whitespace). The keywords
       available for use is defined in this document; we'll refer to
       them in following simply as <I
CLASS="emphasis"
>capabilities</I
>.

     </P
><P
>&#13;
       HAL itself, assigns capabilities on device detection time by
       inspecting the device class (if available, it depends on the
       bus type) and looking at information from the operating system
       (most OS'es have a concept of device classes). At this time the
       category is also determined by selecting the most prominent
       capability. However, both capabilities and category can be
       overridden by either device information files or callouts. This
       gives maximum flexibility, while maintaining a base level of
       capability detection.

     </P
><P
>&#13;
       The idea of HAL is that existing device capability specific
       libraries (such as libghoto2), would advertise what kind of HAL
       capabilities they are able to handle. As this happens over
       time, this specification will grow to precisely define what a
       device with a given capability is supposed to do and what
       library, or service, the application programmer can use to
       access the device.
     
     </P
><P
>&#13;
       Having a capability also means that part of the property
       namespace, prefixed with the capability name, will be populated
       with more specific information about the capability. Indeed,
       some properties may even be required such that applications and
       device libraries have something to expect. For instance, the
       capability for being a MP3 player may require properties
       defining what audio formats the device support, whether it
       support recording of audio, and how to interact with the
       device. For example, the latter may specify ''USB Storage
       Device'' or ''proprietary protocol, use libfooplayer''.

     </P
><P
>&#13;
       Just as device objects can appear and disappear at any time
       (e.g. when a device is plugged in respectively removed),
       capabilities can also appear and disappear - one example of
       this happening is when device drivers are loaded and unloaded.

     </P
><P
>&#13;
       Finally, capabilities have an inheritance scheme, e.g. if a device
       has a capability <TT
CLASS="literal"
>foo.bar</TT
>, it must also have
       the capability <TT
CLASS="literal"
>foo</TT
>.

     </P
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="using-devices"
></A
>Using devices</H1
><P
>&#13;
      While the HAL daemon provides generic operations that apply to
      all devices (though some may be no-ops), HAL is not concerned
      with providing non-generic device operations. Specifically, one
      goal of HAL is to integrate with existing and future libraries
      that target a specific class of devices such as cameras or mp3
      players.

    </P
><P
>&#13;
      For instance, <TT
CLASS="literal"
>libgphoto2</TT
> could be extended
      such that the application programmer can simply pass the UDI of
      the camera he wishes to interact with
      and <TT
CLASS="literal"
>libghoto2</TT
> would then, via D-BUS, acquire
      the bus-specific information required, the address so to speak,
      from the HAL daemon, and then interact directly with the
      hardware.

    </P
><P
>&#13;
      Another option is to use the existing API of the device library
      to discover devices (the library would be using HAL under the
      hood) and provide a function to retrieve the HAL UDI of the
      device. When the library is built without HAL support this
      function returns <TT
CLASS="literal"
>NULL</TT
>, however, when the UDI
      is available, then applications using the library can use the
      UDI both as stable reference to the device and also to extract
      more information directly from the HAL daemon.

    </P
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="device-properties"
></A
>Device Properties</H1
><P
>&#13;      Properties are arranged in a namespaces using ''.'' as a separator
      and are key/value pairs. The value may assume different types; currently
      int32, double, bool and UTF8 strings are supported. The key of a property
      is always an ASCII string without any whitespace. The properties are
      updated in real-time.
    </P
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="properties-metadata"
>Metadata Properties</A
></H2
><P
>&#13;
	The section represents properties that aren't tied to either
	physical or functional characteristics of what the device
	object represents.

      </P
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="device-properties-info"
><TT
CLASS="literal"
>info</TT
> namespace</A
></H3
><P
>&#13;
      The <TT
CLASS="literal"
>info</TT
> namespace contain properties that
      can be considered metadata about device objects. These
      properties are always available.

      </P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN199"
></A
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Key (type)</TH
><TH
>Values</TH
><TH
>Mandatory</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>info.bus</TT
> (string)</TD
><TD
>pci, usb, ide_host, ide, block, usb, usbif, scsi_host, scsi</TD
><TD
>Yes</TD
><TD
>Describes what ''physical'' bus the device is connected to</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>info.udi</TT
> (string)</TD
><TD
>example: /org/freedesktop/Hal/devices/pci_10ec_8139</TD
><TD
>Yes</TD
><TD
>The HAL unique device id</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>info.persistent</TT
> (bool)</TD
><TD
>&nbsp;</TD
><TD
>No, but required if <TT
CLASS="literal"
>info.not_available</TT
> is set to TRUE</TD
><TD
>If this property is set, the device will remain in the
                     the GDL even if the device is unplugged</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>info.not_available</TT
> (bool)</TD
><TD
>&nbsp;</TD
><TD
>No</TD
><TD
>The device is currently not available (it may be unplugged
                     or powered down)</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>info.capabilities</TT
> (string)</TD
><TD
>example: block storage storage.cdrom</TD
><TD
>No</TD
><TD
>A white-space separated list of capabilities describing what the devices does</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>info.category</TT
> (string)</TD
><TD
>example: storage.cdrom</TD
><TD
>No</TD
><TD
>The prominent capability describing what the device is</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>info.product</TT
> (string)</TD
><TD
>examples: ''SleekKeyboard'', ''MouseMan 2003'', ''Volume'', ''LS-120 SLIM3 00 UHD Floppy''</TD
><TD
>No</TD
><TD
>The name of the device</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>info.vendor</TT
> (string)</TD
><TD
>examples: Logitch, Mustek</TD
><TD
>No</TD
><TD
>The name of the vendor of the device</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>info.parent</TT
> (string)</TD
><TD
>example: /org/freedesktop/Hal/devices/ide_1_0</TD
><TD
>Yes, for all non-root device objects</TD
><TD
>The UDI of the device object that this device object
	      is connected to.</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>info.locked</TT
> (bool)</TD
><TD
>&nbsp;</TD
><TD
>No</TD
><TD
>&#13;		If this property is available and set
		to <TT
CLASS="literal"
>TRUE</TT
> it means that a process
		is using the device that the hal device object in
		question represents and no other process should attempt
		to use or configure the device. The lock is only
		advisory.
	      </TD
></TR
><TR
><TD
><TT
CLASS="literal"
>info.locked.reason</TT
> (string)</TD
><TD
>&#13;		example: ''The optical drive is currently being used to
		record a CD-RW disc.''
	      </TD
><TD
>&#13;		Only available if <TT
CLASS="literal"
>info.locked</TT
> is set
		to <TT
CLASS="literal"
>TRUE</TT
>.
	      </TD
><TD
>A localized text suitable for UI display</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>info.locked.dbus_service</TT
> (string)</TD
><TD
>example: :1.278</TD
><TD
>&#13;		Only available if <TT
CLASS="literal"
>info.locked</TT
> is set
		to <TT
CLASS="literal"
>TRUE</TT
>.
	      </TD
><TD
>The base D-BUS service of the process holding the lock.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="device-properties-linux"
><TT
CLASS="literal"
>linux</TT
> namespace</A
></H3
><P
>&#13;	This namespace is used to store Linux-specific metadata about the
	device object and is only available on Linux systems.
      </P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN290"
></A
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Key (type)</TH
><TH
>Values</TH
><TH
>Mandatory</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>linux.sysfs_path</TT
> (string)</TD
><TD
>examples: /sys/block/sda/sda1, /sys/devices/pci0000:00/0000:00:01.0/0000:01:00.0</TD
><TD
>Yes</TD
><TD
>A fully-qualified path into the sysfs filesystem for the
              physical device</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>linux.sysfs_path_device</TT
> (string)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>Normally this property assumes the same value as 
              linux.sysfs_path, however for some devices it assumes an
              alternate location in the sysfs filesystem. It is used
              internally in HAL</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>linux.driver</TT
> (string)</TD
><TD
>examples: agpgart-intel, yenta_cardbus, usb, hub, usbhid</TD
><TD
>No</TD
><TD
>Name of the driver bound to this device</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>linux.kernel_devname</TT
> (string)</TD
><TD
>example: usb-0000:00:07.2-1.2</TD
><TD
>No</TD
><TD
>A name used internally in the Linux kernel to identify
              the device. Used internally in HAL.</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>linux.is_selinux_enabled</TT
> (bool)</TD
><TD
>&nbsp;</TD
><TD
>No; can only appear on the root computer device object</TD
><TD
>Whether SELinux is enabled on the system</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
><P
>&#13;      </P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="properties-bus"
>Physical Properties</A
></H2
><P
>&#13;
	In this section properties for device objects that represent
	physically addressable hardware is described. Availability of
	these depends on the value of the <TT
CLASS="literal"
>info.bus</TT
>
	property.  These properties are not of particular interest to
	application developers, instead they are useful for libraries
	and userspace drivers that needs to interact with the device
	given a UDI. Knowledge of various bus interconnect
	technologies is assumed for this section to be useful.

      </P
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="device-properties-pci"
><TT
CLASS="literal"
>pci</TT
> namespace</A
></H3
><P
>&#13;
	This namespace contains properties for device objects representing
	functions on devices on a PCI bus. These properties are available
	exactly when <TT
CLASS="literal"
>info.bus</TT
> equals <TT
CLASS="literal"
>pci</TT
>.

      </P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN340"
></A
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Key (type)</TH
><TH
>Values</TH
><TH
>Mandatory</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>pci.device_class</TT
> (int)</TD
><TD
>example: 3</TD
><TD
>Yes</TD
><TD
>Device Class</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>pci.device_subclass</TT
> (int)</TD
><TD
>example: 0</TD
><TD
>Yes</TD
><TD
>PCI Device Sub Class</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>pci.device_protocol</TT
> (int)</TD
><TD
>example: 0</TD
><TD
>Yes</TD
><TD
>Device Protocol</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>pci.product_id</TT
> (int)</TD
><TD
>example: 0x4c4d</TD
><TD
>Yes</TD
><TD
>Product ID</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>pci.vendor_id</TT
> (int)</TD
><TD
>example: 0x1002</TD
><TD
>Yes</TD
><TD
>Vendor ID</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>pci.subsys_product_id</TT
> (int)</TD
><TD
>example: 0x009e</TD
><TD
>Yes</TD
><TD
>Subsystem product id</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>pci.subsys_vendor_id</TT
> (int)</TD
><TD
>example: 0x1028</TD
><TD
>Yes</TD
><TD
>Subsystem vendor id</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>pci.linux.sysfs_path</TT
> (string)</TD
><TD
>example: /sys/devices/pci0000:00/0000:00:01/0000:01:00.0</TD
><TD
>Yes (only on Linux)</TD
><TD
>Equals <TT
CLASS="literal"
>linux.sysfs_path</TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>pci.product</TT
> (string)</TD
><TD
>Rage Mobility P/M AGP 2x</TD
><TD
>No</TD
><TD
>Name of the product per the PCI database</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>pci.vendor</TT
> (string)</TD
><TD
>ATI Technologies Inc</TD
><TD
>No</TD
><TD
>Name of the vendor per the PCI database</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>pci.subsys_product</TT
> (string)</TD
><TD
>Inspiron 7500</TD
><TD
>No</TD
><TD
>Name of the subsystem product per the PCI database</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>pci.subsys_vendor</TT
> (string)</TD
><TD
>Dell Computer Corporation</TD
><TD
>No</TD
><TD
>Name of the subsystem vendor per the PCI database</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
><P
>&#13;
      (FIXME: Some key PCI information (bus, slot, port, function
      etc.) is missing here)

      </P
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="device-properties-usb"
><TT
CLASS="literal"
>usb_device</TT
> namespace</A
></H3
><P
>&#13;
	For device objects representing USB devices the property
	<TT
CLASS="literal"
>info.bus</TT
> will be <TT
CLASS="literal"
>usb_device</TT
>, 
	and the following properties will be available. Note that the 
	corresponding USB interfaces are represented by separate
	device objects as children.

      </P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN429"
></A
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Key (type)</TH
><TH
>Values</TH
><TH
>Mandatory</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>usb_device.bus_number</TT
> (int)</TD
><TD
>example: 1</TD
><TD
>Yes</TD
><TD
>The USB bus the device is attached to</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>usb_device.configuration_value</TT
> (int) </TD
><TD
>example: 1</TD
><TD
>Yes</TD
><TD
>The current configuration the USB device is in;
              starting from 1</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>usb_device.num_configurations</TT
> (int)</TD
><TD
>example: 1</TD
><TD
>Yes</TD
><TD
>Number of configurations this USB device 
              can assume</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>usb_device.device_class</TT
> (int)</TD
><TD
>example: 0</TD
><TD
>Yes</TD
><TD
>USB Device Class</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>usb_device.device_subclass</TT
> (int)</TD
><TD
>example: 0</TD
><TD
>Yes</TD
><TD
>USB Device Sub Class</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>usb_device.device_protocol</TT
> (int)</TD
><TD
>example: 0</TD
><TD
>Yes</TD
><TD
>USB Device Protocol</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>usb_device.is_self_powered</TT
> (bool)</TD
><TD
>example: false</TD
><TD
>Yes</TD
><TD
>The device, in the current configuration, is self 
		powered</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>usb_device.can_wake_up</TT
> (bool)</TD
><TD
>example: true</TD
><TD
>Yes</TD
><TD
>The device, in the current configuration, can wake up</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>usb_device.max_power</TT
> (int)</TD
><TD
>example: 98</TD
><TD
>Yes</TD
><TD
>Max power drain of device, in mA</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>usb_device.num_interfaces</TT
> (int)</TD
><TD
>example: 1</TD
><TD
>Yes</TD
><TD
>Number of USB Interfaces in the current configuration</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>usb_device.num_ports</TT
> (int)</TD
><TD
>example: 0</TD
><TD
>Yes</TD
><TD
>Number of ports on a hub. Zero for non-hubs</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>usb_device.port_number</TT
> (int)</TD
><TD
>example: 1</TD
><TD
>Yes</TD
><TD
>The port number on the parent hub that the device is attached to, starting from 1</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>usb_device.speed_bcd</TT
> (int)</TD
><TD
>examples: 0x00150, 0x01200, 0x48000</TD
><TD
>Yes</TD
><TD
>Speed of device, in Mbit/s, in BCD with two decimals</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>usb_device.version_bcd</TT
> (int)</TD
><TD
>examples: 0x0100, 0x0110, 0x0200</TD
><TD
>Yes</TD
><TD
>USB version of device in BCD with two decimals</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>usb_device.level_number</TT
> (int)</TD
><TD
>example: 2</TD
><TD
>Yes</TD
><TD
>Depth in physical USB tree, where the virtual root hub
              is at depth 0</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>usb_device.linux.device_number</TT
> (string)</TD
><TD
>example: 19</TD
><TD
>Yes (only on Linux)</TD
><TD
>USB Device Number as assigned by the Linux kernel</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>usb_device.linux.parent_number</TT
> (string)</TD
><TD
>example: 19</TD
><TD
>Yes (only on Linux)</TD
><TD
>Device number of parent device as assigned by the
              Linux kernel</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>usb_device.linux.sysfs_path</TT
> (string)</TD
><TD
>example: /sys/devices/pci0000:00/0000:00:07.2/usb1/1-1/1-1.1</TD
><TD
>Yes (only on Linux)</TD
><TD
>Equals <TT
CLASS="literal"
>linux.sysfs_path</TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>usb_device.product_id</TT
> (int)</TD
><TD
>example: 0x3005</TD
><TD
>Yes</TD
><TD
>USB Product ID</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>usb_device.vendor_id</TT
> (int)</TD
><TD
>example: 0x04b3</TD
><TD
>Yes</TD
><TD
>USB Vendor ID</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>usb_device.device_revision_bcd</TT
> (int)</TD
><TD
>example: 0x0100</TD
><TD
>Yes</TD
><TD
>Device Revision Number encoded in BCD with two decimals</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>usb_device.serial</TT
> (string)</TD
><TD
>&nbsp;</TD
><TD
>No</TD
><TD
>A string uniquely identifying the instance 
              of the device; ie. it will be different for two devices
              of the same type. Note that the serial number is broken
	      on some USB devices.</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>usb_device.product</TT
> (string)</TD
><TD
>example: IBM USB HUB KEYBOARD</TD
><TD
>No</TD
><TD
>Name of the product per the USB ID Database</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>usb_device.vendor</TT
> (string)</TD
><TD
>example: IBM Corp.</TD
><TD
>No</TD
><TD
>Name of the vendor per the USB ID Database</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="device-properties-usbif"
><TT
CLASS="literal"
>usb</TT
> namespace</A
></H3
><P
>&#13;
	Device objects that represent USB interfaces, ie. when
	<TT
CLASS="literal"
>info.bus</TT
> assumes <TT
CLASS="literal"
>usb</TT
>,
	are represented by the properties below. In addition all
	the <TT
CLASS="literal"
>usb_device.*</TT
> properties from the parent
	USB device is available in this namespace but only with
	the <TT
CLASS="literal"
>usb</TT
> prefix instead of
	<TT
CLASS="literal"
>usb_device</TT
>.

      </P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN592"
></A
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Key (type)</TH
><TH
>Values</TH
><TH
>Mandatory</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>usb.interface.class</TT
> (int)</TD
><TD
>example: 0x03</TD
><TD
>Yes</TD
><TD
>USB Class for the interface</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>usb.interface.subclass</TT
> (int)</TD
><TD
>example: 0x01</TD
><TD
>Yes</TD
><TD
>USB Sub Class for this interface</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>usb.interface.protocol</TT
> (int)</TD
><TD
>example: 0x01</TD
><TD
>Yes</TD
><TD
>USB Protocol for the interface</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>usb.interface.number</TT
> (int)</TD
><TD
>example: 1</TD
><TD
>Yes</TD
><TD
>Number of this interface, starting from zero</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>usb.linux.sysfs_path</TT
> (string)</TD
><TD
>example: /sys/devices/pci0000:00/0000:00:07.2/usb1/1-1/1-1.1/1-1.1:1.0</TD
><TD
>Yes (only on Linux)</TD
><TD
>Equals <TT
CLASS="literal"
>linux.sysfs_path</TT
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="device-properties-ide-host"
><TT
CLASS="literal"
>ide_host</TT
> namespace</A
></H3
><P
>&#13;
	The <TT
CLASS="literal"
>ide_host</TT
> namespace is present for
	device objects where <TT
CLASS="literal"
>info.bus</TT
> is set
	to <TT
CLASS="literal"
>ide_host</TT
>.  Such device objects represent
	IDE and ATA host adaptors for harddisks and optical drives as
	found in the majority of computer systems.

      </P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN639"
></A
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Key (type)</TH
><TH
>Values</TH
><TH
>Mandatory</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>ide_host.number</TT
> (int)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>A unique number identifying the IDE host adaptor</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>ide_host.linux.sysfs_path</TT
> (string)</TD
><TD
>example: /sys/devices/pci0000:00/0000:00:07.1/ide0</TD
><TD
>Yes (only on Linux)</TD
><TD
>Equals <TT
CLASS="literal"
>linux.sysfs_path</TT
></TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="device-properties-ide"
><TT
CLASS="literal"
>ide</TT
> namespace</A
></H3
><P
>&#13;
	ATA and IDE drives are represented by device objects where
	<TT
CLASS="literal"
>info.bus</TT
> equals <TT
CLASS="literal"
>ide</TT
>. The
	following properties are available for such device objects.

      </P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN667"
></A
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Key (type)</TH
><TH
>Values</TH
><TH
>Mandatory</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>ide.host</TT
> (int)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>Corresponds
		to <TT
CLASS="literal"
>ide_host.host_number</TT
> of
		the <TT
CLASS="literal"
>ide_host</TT
> device that is the
		parent of this device object</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>ide.channel</TT
> (int)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>Identifies the IDE channel of the host interface</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="device-properties-scsi_host"
><TT
CLASS="literal"
>scsi_host</TT
> namespace</A
></H3
><P
>&#13;
	The <TT
CLASS="literal"
>scsi_host</TT
> namespace is present for
	device objects where <TT
CLASS="literal"
>info.bus</TT
> is set
	to <TT
CLASS="literal"
>scsi_host</TT
>.  Such device objects represent
	SCSI host adaptors for SCSI devices as found in some computer
	systems.

      </P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN697"
></A
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Key (type)</TH
><TH
>Values</TH
><TH
>Mandatory</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>scsi_host.host</TT
> (int)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>A unique number identifying the SCSI host adaptor</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="device-properties-scsi"
><TT
CLASS="literal"
>scsi</TT
> namespace</A
></H3
><P
>&#13;
	SCSI devices are represented by device objects where
	<TT
CLASS="literal"
>info.bus</TT
> equals <TT
CLASS="literal"
>scsi</TT
>.
	The following properties are available for such device objects.

      </P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN718"
></A
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Key (type)</TH
><TH
>Values</TH
><TH
>Mandatory</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>scsi.host</TT
> (int)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>Corresponds to <TT
CLASS="literal"
>scsi_host.host</TT
>
		of the <TT
CLASS="literal"
>scsi_host</TT
> device that is the
		parent of this device object</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>scsi.bus</TT
> (int)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>SCSI channel number</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>scsi.target</TT
> (int)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>SCSI identifier number</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>scsi.lun</TT
> (int)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>SCSI Logical Unit Number</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="device-properties-ieee1394_host"
><TT
CLASS="literal"
>ieee1394_host</TT
> namespace</A
></H3
><P
>&#13;
	Device objects with <TT
CLASS="literal"
>info.bus</TT
> set to
	<TT
CLASS="literal"
>ieee1394_host</TT
> represent IEEE 1394 host
	adaptors. The following properties are available for such
	device objects.

      </P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN759"
></A
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Key (type)</TH
><TH
>Values</TH
><TH
>Mandatory</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>ieee1394_host.is_busmgr</TT
> (bool)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>TODO</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>ieee1394_host.is_irn</TT
> (bool)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>TODO</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>ieee1394_host.is_root</TT
> (bool)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>TODO</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>ieee1394_host.node_count</TT
> (int)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>TODO</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>ieee1394_host.nodes_active</TT
> (int)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>TODO</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="device-properties-ieee1394_node"
><TT
CLASS="literal"
>ieee1394_node</TT
> namespace</A
></H3
><P
>&#13;
	Device objects with <TT
CLASS="literal"
>info.bus</TT
> set to 
	<TT
CLASS="literal"
>ieee1394_node</TT
> represent IEEE 1394 nodes on
	a IEEE 1394 bus. The following properties are available for
	such device objects.

      </P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN804"
></A
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Key (type)</TH
><TH
>Values</TH
><TH
>Mandatory</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>ieee1394_node.capabilities</TT
> (int)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>TODO</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>ieee1394_node.guid</TT
> (int)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>TODO</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>ieee1394_node.nodeid</TT
> (int)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>TODO</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>ieee1394_node.vendor</TT
> (int)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>TODO</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>ieee1394_node.vendor_id</TT
> (int)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>TODO</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="device-properties-ieee1394"
><TT
CLASS="literal"
>ieee1394</TT
> namespace</A
></H3
><P
>&#13;
	Device objects with <TT
CLASS="literal"
>info.bus</TT
> set to 
	<TT
CLASS="literal"
>ieee1394</TT
> represent IEEE 1394 devices. The 
	following properties are available for such device objects.

      </P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN849"
></A
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Key (type)</TH
><TH
>Values</TH
><TH
>Mandatory</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>ieee1394.specifier_id</TT
> (int)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>TODO</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="device-properties-block"
><TT
CLASS="literal"
>block</TT
> namespace</A
></H3
><P
>&#13;
	Device objects representing addressable block devices, such as
	drives and partitions, will have <TT
CLASS="literal"
>info.bus</TT
>
	set to <TT
CLASS="literal"
>block</TT
> and will export a number of
	properties in the <TT
CLASS="literal"
>block</TT
> namespace.

      </P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN871"
></A
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Key (type)</TH
><TH
>Values</TH
><TH
>Mandatory</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>block.device</TT
> (string)</TD
><TD
>example: /dev/sda </TD
><TD
>Yes</TD
><TD
>Special device file to interact with the block device</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>block.major</TT
> (int)</TD
><TD
>example: 8</TD
><TD
>Yes</TD
><TD
>Major number of special file to interact with the 
              device</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>block.minor</TT
> (int)</TD
><TD
>example: 1</TD
><TD
>Yes</TD
><TD
>Minor number of special file to interact with the 
              device</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>block.is_volume</TT
> (bool)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>True only when the block device is a volume that can
		be mounted into the file system. In this case the
		<TT
CLASS="literal"
>volume</TT
> capability will be set and
		thus, properties, in the <TT
CLASS="literal"
>volume</TT
>
		namespace are available.</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>block.no_partitions</TT
> (bool)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>For toplevel block devices, this is TRUE only
		when no known partition tables have been found on the
		media (In this case, if the storage device contain a
		file system it will be accessible using the same
		special device file as the one for this device object
		and the device object representing the filesystem will
		appear as a separate device object as a child). For
		the child, that is
		when <TT
CLASS="literal"
>block.is_volume</TT
> is true, this
		property is TRUE exactly when it was created for a
		storage device with
		the <TT
CLASS="literal"
>storage.no_partitions_hint</TT
> set
		to TRUE.
	      </TD
></TR
><TR
><TD
><TT
CLASS="literal"
>block.have_scanned</TT
> (bool)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>&#13;		An internal property used by HAL to specify whether a top
		level block device have already been scanned for filesystems.
	      </TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="properties-functional"
>Functional Properties</A
></H2
><P
>&#13;
	The section describe functional properties of device objects,
	that is, properties that are merged onto device objects
	representing physically addressable hardware. In most
	circumstances such properties stem from a kernel level
	driver attached to the device represented by the device object,
	however, as HAL can merge properties from anywhere, they
	may have been merged from device information files or callouts.

      </P
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="device-properties-volume"
><TT
CLASS="literal"
>volume</TT
> namespace</A
></H3
><P
>&#13;
	This namespace is for device objects that represent storage
	devices with a filesystem that can be mounted. Such device
	objects will have the capability <TT
CLASS="literal"
>volume</TT
> and
	they will export the properties below. Note that device
	objects can only have the <TT
CLASS="literal"
>volume</TT
> capability
	if they already have the capability <TT
CLASS="literal"
>block</TT
>
	and the property <TT
CLASS="literal"
>block.is_volume</TT
> set to TRUE.

      </P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN931"
></A
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Key (type)</TH
><TH
>Values</TH
><TH
>Mandatory</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>volume.is_mounted</TT
> (bool)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>This property is TRUE if and only if the volume is mounted</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>volume.mount_point</TT
> (string)</TD
><TD
>example: /media/compact_flash1  </TD
><TD
>Yes (is blank only when volume.is_mounted is FALSE)</TD
><TD
>A fully qualified path to the mount point of the volume</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>volume.fsusage</TT
> (string)</TD
><TD
>example: filesystem</TD
><TD
>Yes</TD
><TD
>&#13;                This property specifies the expected usage of the volume
              </TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>filesystem</TD
><TD
>&nbsp;</TD
><TD
>The volume is a mountable filesystem</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>partitiontable</TD
><TD
>&nbsp;</TD
><TD
>The volume conatains a partitiontable</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>raid</TD
><TD
>&nbsp;</TD
><TD
>The volume is a member of a raid set and not mountable</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>other</TD
><TD
>&nbsp;</TD
><TD
>The volume is not mountable like a swap partition</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>unused</TD
><TD
>&nbsp;</TD
><TD
>The volume is marked a unused or free</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>volume.fstype</TT
> (string)</TD
><TD
>example: ext3</TD
><TD
>Yes (is blank if the filesystem type is unknown)</TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>volume.fsversion</TT
> (string)</TD
><TD
>example: FAT32</TD
><TD
>&nbsp;</TD
><TD
>Version number or subtype of the filesystem</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>volume.label</TT
> (string)</TD
><TD
>example: 'Fedora Core 1.90' </TD
><TD
>Yes (is blank if no label is found)</TD
><TD
>The label of the volume</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>volume.uuid</TT
> (string)</TD
><TD
>example: 4060-6C11</TD
><TD
>Yes (is blank if no UUID is found)</TD
><TD
>The Universal Unique Identifer for the volume</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>volume.is_disc</TT
> (bool)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>If the volume stems from an optical disc, this
              property is true and the device object will also have
              the capability <TT
CLASS="literal"
>volume.disc</TT
></TD
></TR
><TR
><TD
><TT
CLASS="literal"
>volume.block_size</TT
> (string)</TD
><TD
>&nbsp;</TD
><TD
>No</TD
><TD
>&#13;		The block size of the volume
	      </TD
></TR
><TR
><TD
><TT
CLASS="literal"
>volume.num_blocks</TT
> (string)</TD
><TD
>&nbsp;</TD
><TD
>No</TD
><TD
>&#13;		Number of blocks on the volume
	      </TD
></TR
><TR
><TD
><TT
CLASS="literal"
>volume.size</TT
> (uint64)</TD
><TD
>&nbsp;</TD
><TD
>No</TD
><TD
>&#13;		Size of the volume in bytes
	      </TD
></TR
><TR
><TD
><TT
CLASS="literal"
>volume.is_partition</TT
> (bool)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>&#13;		If the volume stems from a partition on e.g. a hard
		disk, this property is set to <TT
CLASS="literal"
>TRUE</TT
>.
	      </TD
></TR
><TR
><TD
><TT
CLASS="literal"
>volume.partition.number</TT
> (int)</TD
><TD
>&nbsp;</TD
><TD
>&#13;		If, and only if, <TT
CLASS="literal"
>volume.is_partition</TT
>
		is set to <TT
CLASS="literal"
>TRUE</TT
>.
	      </TD
><TD
>&#13;		The number of the partition.
	      </TD
></TR
><TR
><TD
><TT
CLASS="literal"
>volume.partition.x86_type</TT
> (int)</TD
><TD
>examples: 0x83, 0xfd, 0x8e</TD
><TD
>&#13;		No
	      </TD
><TD
>&#13;		If available, this is the partition type if the disk for which
		this volume stems from is using an MS-DOS-style partition table.
	      </TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
><P
>&#13;	Device objects with this capability may emit the following
	device conditions
      </P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN1054"
></A
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Condition Name</TH
><TH
>Parameters</TH
><TH
>Example</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>VolumeMount</TT
></TD
><TD
>&#13;		<TT
CLASS="literal"
>block.device</TT
> (string),
		<TT
CLASS="literal"
>volume.mount_point</TT
> (string)
	      </TD
><TD
>&#13;		<TT
CLASS="literal"
>/dev/sda1</TT
>,
		<TT
CLASS="literal"
>/media/compact_flash</TT
>
	      </TD
><TD
>Emitted when a volume is mounted</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>VolumeUnmount</TT
></TD
><TD
>&#13;		<TT
CLASS="literal"
>block.device</TT
> (string),
		<TT
CLASS="literal"
>volume.mount_point</TT
> (string)
	      </TD
><TD
>&#13;		<TT
CLASS="literal"
>/dev/sda1</TT
>,
		<TT
CLASS="literal"
>/media/compact_flash</TT
>
	      </TD
><TD
>Emitted when a volume is unmounted</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>VolumeUnmountForced</TT
></TD
><TD
>&#13;		<TT
CLASS="literal"
>block.device</TT
> (string),
		<TT
CLASS="literal"
>volume.mount_point</TT
> (string)
	      </TD
><TD
>&#13;		<TT
CLASS="literal"
>/dev/sda1</TT
>,
		<TT
CLASS="literal"
>/media/compact_flash</TT
>
	      </TD
><TD
>&#13;		Emitted when a volume is forcibly unmounted because
		the media backing the volume was removed.
	      </TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="device-properties-kernel"
><TT
CLASS="literal"
>kernel</TT
> namespace</A
></H3
><P
>&#13;
	This namespace is found on the toplevel "Computer" device,
	and represents information about the currently running kernel.

      </P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN1097"
></A
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Key (type)</TH
><TH
>Values</TH
><TH
>Mandatory</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>kernel.name</TT
> (string)</TD
><TD
>example: Linux</TD
><TD
>No</TD
><TD
>&#13;                The name of the kernel, usually the equivalent of
                <TT
CLASS="literal"
>uname -s</TT
>.
              </TD
></TR
><TR
><TD
><TT
CLASS="literal"
>kernel.version</TT
> (string)</TD
><TD
>example: 2.6.5-7.104-default</TD
><TD
>No</TD
><TD
>&#13;                The version of the currently running kernel.  Usually
                the equivalent of <TT
CLASS="literal"
>uname -r</TT
>.
              </TD
></TR
><TR
><TD
><TT
CLASS="literal"
>kernel.machine</TT
> (string)</TD
><TD
>example: i686</TD
><TD
>No</TD
><TD
>&#13;                The "machine hardware name" of the currently running kernel.
                Usually the equivalent of <TT
CLASS="literal"
>uname -m</TT
>.
	      </TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="device-properties-volume-disc"
><TT
CLASS="literal"
>volume.disc</TT
> namespace</A
></H3
><P
>&#13;
	This namespace is for device objects that represent optical
	discs, e.g. device objects with the capability 
	<TT
CLASS="literal"
>volume.disc</TT
>. Such device objects will
	also have the capability <TT
CLASS="literal"
>volume</TT
>.

      </P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN1133"
></A
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Key (type)</TH
><TH
>Values</TH
><TH
>Mandatory</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>volume.disc.has_audio</TT
> (bool)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>Is true only if the disc contains audio</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>volume.disc.has_data</TT
> (bool)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>Is true only if the disc contains data</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>volume.disc.is_appendable</TT
> (bool)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>Is true only if it's possible to write additional data</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>volume.disc.is_blank</TT
> (bool)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>Is true only if the disc is blank</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>volume.disc.is_rewritable</TT
> (bool)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>Is true only if the disc is rewritable</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>volume.disc.type</TT
> (string)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>This property specifies the physical type of the disc</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>cd_rom</TD
><TD
>&nbsp;</TD
><TD
>CD-ROM disc</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>cd_r</TD
><TD
>&nbsp;</TD
><TD
>CD-R disc</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>cd_rw</TD
><TD
>&nbsp;</TD
><TD
>CD-RW disc</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>dvd_rom</TD
><TD
>&nbsp;</TD
><TD
>DVD-ROM disc</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>dvd_ram</TD
><TD
>&nbsp;</TD
><TD
>DVD-RAM disc</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>dvd_r</TD
><TD
>&nbsp;</TD
><TD
>DVD-R disc</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>dvd_rw</TD
><TD
>&nbsp;</TD
><TD
>DVD-RW disc</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>dvd_plus_r</TD
><TD
>&nbsp;</TD
><TD
>DVD+R disc</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>dvd_plus_rw</TD
><TD
>&nbsp;</TD
><TD
>DVD+RW disc</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>unknown</TD
><TD
>&nbsp;</TD
><TD
>Unknown type or lack of support from drive to determine the type</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="device-properties-storage"
><TT
CLASS="literal"
>storage</TT
> namespace</A
></H3
><P
>&#13;
	This namespace is used to describe physical storage devices
	and their capabilities. Such device objects will have the 
	capability <TT
CLASS="literal"
>storage</TT
> and
	they will export the properties below. Note that device
	objects can only have the <TT
CLASS="literal"
>storage</TT
> capability
	if they already got capability <TT
CLASS="literal"
>block</TT
> and the
	property <TT
CLASS="literal"
>block.is_volume</TT
> set to FALSE.
	One significant between the <TT
CLASS="literal"
>storage</TT
> and
	<TT
CLASS="literal"
>block</TT
> namespace is that the properties
	exported in the <TT
CLASS="literal"
>storage</TT
> represents
	constant vital product information, whereas the properties
	in the <TT
CLASS="literal"
>block</TT
> namespace represent 
	variable system-dependent information.

      </P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN1240"
></A
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Key (type)</TH
><TH
>Values</TH
><TH
>Mandatory</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>storage.bus</TT
> (string)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>Physical interface the storage device is attached to</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>ide</TD
><TD
>&nbsp;</TD
><TD
>IDE or ATA interface</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>usb</TD
><TD
>&nbsp;</TD
><TD
>USB interface</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>ieee1394</TD
><TD
>&nbsp;</TD
><TD
>IEEE 1394 interface</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>scsi</TD
><TD
>&nbsp;</TD
><TD
>SCSI interface</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>sata</TD
><TD
>&nbsp;</TD
><TD
>SATA interface</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>platform</TD
><TD
>&nbsp;</TD
><TD
>Legacy device that is part of the platform</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>storage.drive_type</TT
> (string)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>&#13;		The type of the drive. Note that it may not be
		possible to probe for some of these properties so in
		some cases memory card readers may appear as
		harddisks. Device information files can be used to
		override this value.
	      </TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>disk</TD
><TD
>&nbsp;</TD
><TD
>The device is a harddisk</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>cdrom</TD
><TD
>&nbsp;</TD
><TD
>The device is an optical drive. The device object will also have the capability <TT
CLASS="literal"
>storage.cdrom</TT
> in this case.</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>floppy</TD
><TD
>&nbsp;</TD
><TD
>The device is a floppy disk drive</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>tape</TD
><TD
>&nbsp;</TD
><TD
>The device is a tape drive</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>compact_flash</TD
><TD
>&nbsp;</TD
><TD
>The device is a card reader for Compact Flash memory cards</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>memory_stick</TD
><TD
>&nbsp;</TD
><TD
>The device is a card reader for MemoryStick memory cards</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>smart_media</TD
><TD
>&nbsp;</TD
><TD
>The device is a card reader for SmartMedia memory cards</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>sd_mmc</TD
><TD
>&nbsp;</TD
><TD
>The device is a card reader for SecureDigital/MultiMediaCard memory cards</TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>storage.removable</TT
> (bool)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>Media can be removed from the storage device</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>storage.requires_eject</TT
> (bool)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>The eject ioctl is required to properly eject the media</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>storage.hotpluggable</TT
> (bool)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>The storage device can be removed while the system is running</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>storage.media_check_enabled</TT
> (bool)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>If this property is set to FALSE then HAL will not continuosly poll for media changes. </TD
></TR
><TR
><TD
><TT
CLASS="literal"
>storage.automount_enabled_hint</TT
> (bool)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>This property is a hint to desktop file managers that they shouldn't automount volumes of the storage device when they appear.</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>storage.no_partitions_hint</TT
> (bool)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>&#13;		This property is a hint to programs that maintain the 
		<TT
CLASS="literal"
>/etc/fstab</TT
> file to signal, when
		TRUE, that the storage drive (such as floppy or
		optical drives) is used for media with no partition
		table so an entry can be added ahead of media
		insertion time. Note that this is only a hint; media
		may be inserted that has partition tables that the
		kernel may respect. Conversely, when this is FALSE
		media without partition tables may be inserted (an
		example is a Compact Flash card; this media is normally
		formatted with a PC style partition table and a single
		FAT partition. However, it may be formatted with just
		a single FAT partition and no partition table).
	      </TD
></TR
><TR
><TD
><TT
CLASS="literal"
>storage.physical_device</TT
> (string)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>&#13;		This contains the UDI of the device object
		representing the physical device or blank if 
		there is no such device (which is TRUE for legacy
		devices such as x86 floppy drives). Additionally, a
		number of properties are merged from that device
		object. Specifically, all properties prefixed
		with <TT
CLASS="literal"
>storage</TT
> and, if the physical
		device has several storage ports,
		<TT
CLASS="literal"
>storage_lunX</TT
> (where X is number of
		the port starting from zero) are merged and will have 
		the prefix <TT
CLASS="literal"
>storage</TT
>.  See <A
HREF="#fdi-example-6in1"
>the Section called <I
>Example: Card Reader</I
> in the Chapter called <I
>Device Information Files</I
></A
> for an example.
	      </TD
></TR
><TR
><TD
><TT
CLASS="literal"
>storage.model</TT
> (string)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>The name of the drive</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>storage.vendor</TT
> (string)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>The vendor of the drive</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>storage.serial</TT
> (string)</TD
><TD
>&nbsp;</TD
><TD
>No</TD
><TD
>The serial number of the drive</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>storage.firmware_revision</TT
> (string)</TD
><TD
>&nbsp;</TD
><TD
>No</TD
><TD
>The revision of the firmware of the drive</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>storage.icon.drive</TT
> (string)</TD
><TD
>&nbsp;</TD
><TD
>No</TD
><TD
>&#13;		Name of icon to use for displaying the drive. The name
		must comply with freedesktop.org icon-theme specification
		and must not be an absolute path.
		
		This property exists such that e.g. OEM's can install
		icons in <TT
CLASS="literal"
>/usr/share/icons/hicolor</TT
>
		a device information file matching their device.
	      </TD
></TR
><TR
><TD
><TT
CLASS="literal"
>storage.icon.volume</TT
> (string)</TD
><TD
>&nbsp;</TD
><TD
>No</TD
><TD
>&#13;		Name of icon to use for displaying volumes from the drive.
		The name must comply with freedesktop.org icon-theme
		specification and must not be an absolute path.
		
		This property exists such that e.g. OEM's can install
		icons in <TT
CLASS="literal"
>/usr/share/icons/hicolor</TT
>
		a device information file matching their device.
	      </TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="device-properties-storage-cdrom"
><TT
CLASS="literal"
>storage.cdrom</TT
> namespace</A
></H3
><P
>&#13;
	This namespace is used to describe optical storage drives
	and their capabilities.Such device objects will have the 
	capability <TT
CLASS="literal"
>storage.cdrom</TT
> and
	they will export the properties below. Note that device
	objects can only have the <TT
CLASS="literal"
>storage.cdrom</TT
> capability
	if they already got the capability <TT
CLASS="literal"
>storage</TT
>.

      </P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN1434"
></A
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Key (type)</TH
><TH
>Values</TH
><TH
>Mandatory</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>storage.cdrom.cdr</TT
> (bool)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>TRUE when the optical drive can write CD-R discs</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>storage.cdrom.cdrw</TT
> (bool)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>TRUE when the optical drive can blank and write to CD-RW discs</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>storage.cdrom.dvd</TT
> (bool)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>TRUE when the optical drive can read DVD-ROM discs</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>storage.cdrom.dvdr</TT
> (bool)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>TRUE when the optical drive can write to DVD-R discs</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>storage.cdrom.dvdrw</TT
> (bool)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>TRUE when the optical drive can blank and write to DVD-RW discs</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>storage.cdrom.dvdram</TT
> (bool)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>TRUE when the optical drive can write to DVD-RAM discs</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>storage.cdrom.dvdplusr</TT
> (bool)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>TRUE when the optical drive can write to DVD+R discs</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>storage.cdrom.dvdplusrw</TT
> (bool)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>TRUE when the optical drive can blank and write to DVD+RW discs</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>storage.cdrom.support_media_changed</TT
> (bool)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>TRUE if the drive can generate media changed events</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>storage.cdrom.read_speed</TT
> (int)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>The maximum reading speed, in kb/s</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>storage.cdrom.write_speed</TT
> (int)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>The maximum writing speed, in kb/s</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="device-properties-net"
><TT
CLASS="literal"
>net</TT
> namespace</A
></H3
><P
>&#13;
	This namespace is used to describe networking devices and
	their capabilities.Such device objects will have the
	capability <TT
CLASS="literal"
>net</TT
> and they will export the
	properties below. This namespace only describe the generic
	aspect of networking devices; specific networking technologies
	such as IEEE 802.3 and IEEE 802.11 have separate namespaces.

      </P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN1514"
></A
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Key (type)</TH
><TH
>Values</TH
><TH
>Mandatory</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>net.address</TT
> (string)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>Hardware address as a string. Is hardware dependant</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>net.arp_proto_hw_id</TT
> (string)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>ARP protocol hardware identifier</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>net.interface</TT
> (string)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>Name of the interface; may change if an interface is
	      renamed</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>net.interface_up</TT
> (bool)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>Whether the interface is up</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>net.linux.ifindex</TT
> (string)</TD
><TD
>&nbsp;</TD
><TD
>Yes (only on Linux)</TD
><TD
>Index of the interface</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>net.linux.sysfs_path</TT
> (string)</TD
><TD
>&nbsp;</TD
><TD
>Yes (only on Linux)</TD
><TD
>Path of device in sysfs</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>net.media</TT
> (string)</TD
><TD
>example: Ethernet</TD
><TD
>Yes</TD
><TD
>Textual description of the networking media</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="device-properties-net-80203"
><TT
CLASS="literal"
>net.80203</TT
> namespace</A
></H3
><P
>&#13;
	Ethernet networking devices is described in this namespace
	for device objects with the capability 
	<TT
CLASS="literal"
>net.80203</TT
>.
	Note that device
	objects can only have the <TT
CLASS="literal"
>net.80203</TT
> capability
	if they already have the capability <TT
CLASS="literal"
>net</TT
>.

      </P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN1572"
></A
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Key (type)</TH
><TH
>Values</TH
><TH
>Mandatory</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>net.80203.link</TT
> (bool)</TD
><TD
>&nbsp;</TD
><TD
>&#13;		Only if the <TT
CLASS="literal"
>net.80203</TT
> capability is set
		and <TT
CLASS="literal"
>net.interface_up</TT
> is
		<TT
CLASS="literal"
>TRUE</TT
>.
	      </TD
><TD
>True iff the ethernet adaptor is connected to a
              another transceiver</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>net.80203.rate</TT
> (uint64)</TD
><TD
>example: 100000000</TD
><TD
>&#13;		Only if the <TT
CLASS="literal"
>net.80203</TT
> capability is set
		and <TT
CLASS="literal"
>net.80203.link</TT
> is
		<TT
CLASS="literal"
>TRUE</TT
>.
	      </TD
><TD
>Bandwidth of connection, in bits/s</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>net.80203.mac_address</TT
> (uint64)</TD
><TD
>example: 0x0010605d8ef4</TD
><TD
>Only if the <TT
CLASS="literal"
>net.80203</TT
> is set</TD
><TD
>48-bit address</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
><P
>&#13;      </P
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="device-properties-net-80211"
><TT
CLASS="literal"
>net.80211</TT
> namespace</A
></H3
><P
>&#13;
	Wireless ethernet networking devices is described in this namespace
	for device objects with the capability 
	<TT
CLASS="literal"
>net.80211</TT
>.
	Note that device
	objects can only have the <TT
CLASS="literal"
>net.80211</TT
> capability
	if they already have the capability <TT
CLASS="literal"
>net</TT
>.

      </P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN1614"
></A
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Key (type)</TH
><TH
>Values</TH
><TH
>Mandatory</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>net.80211.mac_address</TT
> (uint64)</TD
><TD
>example: 0x0010605d8ef4</TD
><TD
>&#13;		Only if the <TT
CLASS="literal"
>net.80211</TT
> capability is set
	      </TD
><TD
>48-bit address</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
><P
>&#13;      </P
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="device-properties-input"
><TT
CLASS="literal"
>input</TT
> namespace</A
></H3
><P
>&#13;      
	This namespace is concerned with human input devices such as
	keyboards, mice, pointing devices and game controllers. If a
	device object has the capability <TT
CLASS="literal"
>input</TT
> then
	the following properties are available
      
      </P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN1636"
></A
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Key (type)</TH
><TH
>Values</TH
><TH
>Mandatory</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>input.device</TT
> (string)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>Special device file for recieving input events</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="device-properties-pcmcia_socket"
><TT
CLASS="literal"
>pcmcia_socket namespace</TT
></A
></H3
><P
>&#13;      
	Device objects with the capability <TT
CLASS="literal"
>pcmcia_socket</TT
>
	represent bridge devices (the actual bus of the device may differ)
	that PCMCIA cards can be attached to. The following properties are
	available.
      
      </P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN1656"
></A
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Key (type)</TH
><TH
>Values</TH
><TH
>Mandatory</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>pcmcia_socket.number</TT
> (int)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>PCMCIA socket number, starting from zero</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="device-properties-printer"
><TT
CLASS="literal"
>printer</TT
> namespace</A
></H3
><P
>&#13;      
	Device objects with the capability <TT
CLASS="literal"
>printer</TT
>
	represent printers. The following properties are available.
      
      </P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN1676"
></A
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Key (type)</TH
><TH
>Values</TH
><TH
>Mandatory</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>printer.device</TT
> (string)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>TODO</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>printer.vendor</TT
> (string)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>TODO</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>printer.product</TT
> (string)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>TODO</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>printer.serial</TT
> (string)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>TODO</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>printer.description</TT
> (string)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>TODO</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="device-properties-portable_audio_player"
><TT
CLASS="literal"
>portable_audio_player</TT
> namespace</A
></H3
><P
>&#13;      
	Device objects with the capability 
	<TT
CLASS="literal"
>portable_audio_player</TT
> represent portable
	audio players that can be attached to a computer to exchange
	files. They can also playback audio. Sometimes they can also
	record audio. This capability can't, in general, be reliably
	probed from the hardware so the information needs to be merged
	from either device information files or callouts. Therefore
	this capability should be merged on the appropriate device
	object that represents the addressable piece of hardware that
	is the portable music player; for USB devices this would be
	the device object representing the appropriate USB
	interface. The following properties are available:
      
      </P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN1720"
></A
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Key (type)</TH
><TH
>Values</TH
><TH
>Mandatory</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>portable_audio_player.access_method</TT
> (string)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>This property defines how the device is accessed </TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>storage</TD
><TD
>&nbsp;</TD
><TD
>&#13;		The device is accessed as a Mass Storage device
		through a kernel driver.  Application Developers
		should descent down the device object tree to find the
		device object of capability
		<TT
CLASS="literal"
>storage</TT
> in order to access the
		device.
	      </TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>user</TD
><TD
>&nbsp;</TD
><TD
>&#13;		The device is accessed from userspace through
		a userspace driver.
	      </TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>portable_audio_player.output_formats</TT
> (string)</TD
><TD
>example: 'audio/mpeg audio/x-ms-wma</TD
><TD
>Yes</TD
><TD
>&#13;		A whitespace-separated list of MIME-types representing 
		the kind of audio formats that the device can play back
	      </TD
></TR
><TR
><TD
><TT
CLASS="literal"
>portable_audio_player.input_formats</TT
> (string)</TD
><TD
>example: 'audio/x-wav</TD
><TD
>Yes</TD
><TD
>&#13;		A whitespace-separated list of MIME-types representing 
		the kind of audio formats that the device can record. If
		empty, it means that the device is not capable of recording.
	      </TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="device-properties-camera"
><TT
CLASS="literal"
>camera</TT
> namespace</A
></H3
><P
>&#13;      
	Device objects with the capability <TT
CLASS="literal"
>camera</TT
>
	represent digital still cameras that can be attached to a
	computer to exchange files. This does not include card readers
	for memory cards used for cameras. This capability can't, in
	general, be reliably probed from the hardware so the
	information needs to be merged from either device information
	files or callouts. Therefore this capability should be merged
	on the appropriate device object that represents the
	addressable piece of hardware that is the digital still
	camera; for USB devices this would be the device object
	representing the appropriate USB interface. The following
	properties are available:
      
      </P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN1768"
></A
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Key (type)</TH
><TH
>Values</TH
><TH
>Mandatory</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>camera.access_method</TT
> (string)</TD
><TD
>&nbsp;</TD
><TD
>Yes</TD
><TD
>This property defines how the device is accessed </TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>storage</TD
><TD
>&nbsp;</TD
><TD
>&#13;		The device is accessed as a Mass Storage device
		through a kernel driver.  Application Developers
		should descent down the device object tree to find the
		device object of capability
		<TT
CLASS="literal"
>storage</TT
> in order to access the
		device.
	      </TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>user</TD
><TD
>&nbsp;</TD
><TD
>&#13;		The device is accessed from userspace through
		a userspace driver.
	      </TD
></TR
><TR
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
><TD
>&nbsp;</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>camera.libgphoto2.support</TT
> (bool)</TD
><TD
>&nbsp;</TD
><TD
>No</TD
><TD
>&#13;		If true, the device is supported by a userspace driver
		from the libgphoto2 project.
	      </TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="properties-policy"
>Policy Properties</A
></H2
><P
>&#13;
	The properties on a hal device object can be used to express
	certain policies about how the device is to be used. This
	information can be used by either programs querying hal
	directly or by hal callouts. Default policy (e.g. always
	mount a file system with the option 'exec') can also be
	merged on the root computer device object.
      </P
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="device-properties-storage-policy-default"
><TT
CLASS="literal"
>storage.policy.default</TT
> namespace</A
></H3
><P
>&#13;	This namespace specifies the default policy for storage 
	devices - these properties should be merged on the root computer
	device object.
      </P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN1812"
></A
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Key (type)</TH
><TH
>Values</TH
><TH
>Mandatory</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>storage.policy.default.use_managed_keyword</TT
> (string)</TD
><TD
>&nbsp;</TD
><TD
>No</TD
><TD
>&#13;		Whether to use a <I
CLASS="emphasis"
>managed no
	        operation</I
> keyword when adding entries to
	        the File Systems file (<TT
CLASS="literal"
>/etc/fstab</TT
>) - 
		this is used to identify entries added by a program
		that modifies this file.
	      </TD
></TR
><TR
><TD
><TT
CLASS="literal"
>storage.policy.default.managed_keyword.primary</TT
> (string)</TD
><TD
>Example: 'managed'</TD
><TD
>No</TD
><TD
>No-op keyword to use when adding entries to the file systems file</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>storage.policy.default.managed_keyword.secondary</TT
> (string)</TD
><TD
>Example: 'kudzu'</TD
><TD
>No</TD
><TD
>&#13;		Secondary no-op keyword that identifies entries added
		to the file systems file. The secondary keyword is never
		written; only read. This is useful when making a transition
		from one managed keyword to another.
	      </TD
></TR
><TR
><TD
><TT
CLASS="literal"
>storage.policy.default.mount_option.*</TT
> (bool)</TD
><TD
>Examples: 
		<TT
CLASS="literal"
>.noauto</TT
>, 
		<TT
CLASS="literal"
>.exec</TT
>, 
		<TT
CLASS="literal"
>.console</TT
>, 
		<TT
CLASS="literal"
>.fscontext=system_u:object_r:removable_t</TT
></TD
><TD
>No</TD
><TD
>&#13;		This is actually an entire namespace that specifies
	        what options a storage device should be mounted with,
	        e.g. the example <TT
CLASS="literal"
>.exec</TT
> should be read as
		<TT
CLASS="literal"
>storage.policy.default.mount_option.exec</TT
>
	      </TD
></TR
><TR
><TD
><TT
CLASS="literal"
>storage.policy.default.mount_root</TT
> (string)</TD
><TD
>Example: <TT
CLASS="literal"
>/media</TT
> </TD
><TD
>No</TD
><TD
>&#13;		The default mount root to use when computing what
		mount point to use for a storage device
	      </TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="device-properties-storage-policy"
><TT
CLASS="literal"
>storage.policy</TT
> namespace</A
></H3
><P
>&#13;	This namespace contains properties that can be merged on
	individual storage devices to specify how and if the storage
	device should be mounted.
      </P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN1864"
></A
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Key (type)</TH
><TH
>Values</TH
><TH
>Mandatory</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>storage.policy.should_mount</TT
> (bool)</TD
><TD
>&nbsp;</TD
><TD
>No</TD
><TD
>Whether any volumes from this storage device
              should be mounted</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>storage.policy.desired_mount_point</TT
> (string)</TD
><TD
>&nbsp;</TD
><TD
>&#13;		No (only applicable if the
		property <TT
CLASS="literal"
>storage.no_partitions_hint</TT
>
		is set to TRUE)
	      </TD
><TD
>&#13;		The desired mount point for this storage device. The
		path must not be fully qualified and there is no
		guarantee that and storage policy agents, such as
		policy mount wrappers or programs modifying the file
		systems file will use this mount point.
	      </TD
></TR
><TR
><TD
><TT
CLASS="literal"
>storage.policy.mount_option.*</TT
> (bool)</TD
><TD
>&nbsp;</TD
><TD
>&#13;		No (only applicable if the
		property <TT
CLASS="literal"
>storage.no_partitions_hint</TT
>
		is set to TRUE)
	      </TD
><TD
>&#13;		Mount options to use, see property <TT
CLASS="literal"
>storage.policy.default.mount_option.*</TT
>
		for details.
	      </TD
></TR
><TR
><TD
><TT
CLASS="literal"
>storage.policy.mount_filesystem</TT
> (string)</TD
><TD
>&nbsp;</TD
><TD
>&#13;		No (only applicable if the
		property <TT
CLASS="literal"
>storage.no_partitions_hint</TT
>
		is set to TRUE)
	      </TD
><TD
>File system to use when mounting the storage device.</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="device-properties-volume-policy"
><TT
CLASS="literal"
>volume.policy</TT
> namespace</A
></H3
><P
>&#13;	This namespace contains properties that can be merged on
	individual volumes to specify how and if the volume
	should be mounted.
      </P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN1905"
></A
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Key (type)</TH
><TH
>Values</TH
><TH
>Mandatory</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="literal"
>volume.policy.should_mount</TT
> (bool)</TD
><TD
>&nbsp;</TD
><TD
>No</TD
><TD
>Whether this volume should be mounted at all</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>volume.policy.mount_filesystem</TT
> (string)</TD
><TD
>&nbsp;</TD
><TD
>No</TD
><TD
>File system to use when mounting the volume.</TD
></TR
><TR
><TD
><TT
CLASS="literal"
>volume.policy.desired_mount_point</TT
> (string)</TD
><TD
>&nbsp;</TD
><TD
>No</TD
><TD
>&#13;		The desired mount point for this volume. The
		path must not be fully qualified and there is no
		guarantee that and storage policy agents, such as
		policy mount wrappers or programs modifying the file
		systems file will use this mount point.
	      </TD
></TR
><TR
><TD
><TT
CLASS="literal"
>volume.policy.mount_options.*</TT
> (string)</TD
><TD
>&nbsp;</TD
><TD
>No</TD
><TD
>&#13;		Mount options to use, see property <TT
CLASS="literal"
>storage.policy.default.mount_option.*</TT
>
		for details.
	      </TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="spec-device-info"
></A
>Device Information Files</H1
><P
>&#13;
      Device information files (<TT
CLASS="literal"
>.fdi</TT
> files is a
      shorthand) are used to merge arbitrary properties onto device
      objects. The way device information files works is that once all
      physical properties are merged onto a device object it is tried
      against the set of installed device information files.  Device
      information files are used for both merging facts and policy
      settings about devices.

    </P
><P
>&#13;
      Each device information file got a number of
      <TT
CLASS="literal"
>&#60;match key="some_property"
      [string|int|bool|..]="required_value" &#62;</TT
> directives
      that is tested against the properties of the device object. If
      all the match directives passes then the device information can
      include <TT
CLASS="literal"
>&#60;[merge|append] key="some_property"
      type="[string|int|bool|..]"&#62;</TT
> directives to
      respectively merge new properties or append to existing
      properties on the device object. It's important to emphasize
      that any previously property stemming from device detection can
      be overridden by a device information file.

    </P
><P
>&#13;
      The <TT
CLASS="literal"
>&#60;match&#62;</TT
>, 
      <TT
CLASS="literal"
>&#60;merge&#62;</TT
> and
      <TT
CLASS="literal"
>&#60;append&#62;</TT
> directives always requires
      the <TT
CLASS="literal"
>key</TT
> attribute which must be either a
      property name on the device object in question or a path to a
      property on another device object. The latter case is expressed
      either through direct specification of the UDI, such as 
      <TT
CLASS="literal"
>/org/freedesktop/Hal/devices/computer:foo.bar</TT
>
      or indirect references such as 
      <TT
CLASS="literal"
>@info.parent:baz</TT
> where the latter means that
      the device object specified by the UDI in the string property 
      <TT
CLASS="literal"
>info.parent</TT
> should be used to query the
      property <TT
CLASS="literal"
>baz</TT
>. It is also possible to use
      multiple indirections, e.g. for a volume on a USB memory stick
      the indirection <TT
CLASS="literal"
>@block.storage_device:@storage.physical_device:usb.vendor_id</TT
>
      will reference the <TT
CLASS="literal"
>usb.vendor_id</TT
> property
      on the device object representing the USB interface.

    </P
><P
>&#13;
      When the property to match have been determined a number of
      attributes can be used within the <TT
CLASS="literal"
>&#60;match&#62;</TT
>
      tag:
       <P
></P
><UL
><LI
><P
>&#13;	     <TT
CLASS="literal"
>string</TT
> - match a string property; for example
	     <TT
CLASS="literal"
>&#60;match key="foo.bar" string="baz"&#62;</TT
>
	     will match only if 'foo.bar' is a string property assuming the value 'baz'.
	 </P
></LI
><LI
><P
>&#13;	     <TT
CLASS="literal"
>int</TT
> - match an integer property
	 </P
></LI
><LI
><P
>&#13;	     <TT
CLASS="literal"
>uint64</TT
> - match property with the 64-bit unsigned type
	 </P
></LI
><LI
><P
>&#13;	     <TT
CLASS="literal"
>bool</TT
> - match a boolean property
	 </P
></LI
><LI
><P
>&#13;	     <TT
CLASS="literal"
>double</TT
> - match a property of type double
	 </P
></LI
><LI
><P
>&#13;	     <TT
CLASS="literal"
>exists</TT
> - used as 
	     <TT
CLASS="literal"
>&#60;match key="foo.bar" exists="true"&#62;</TT
>. Can be used with
	     'true' and 'false' respectively to match when a property exists and it doesn't.
	 </P
></LI
><LI
><P
>&#13;	     <TT
CLASS="literal"
>empty</TT
> - can only be used on string properties with 'true' and 'false'. The semantics
	     for 'true' is to match only when the string is non-empty.
	 </P
></LI
><LI
><P
>&#13;	     <TT
CLASS="literal"
>is_absolute_path</TT
> - matches only when a string property represents an absolute path
	     (the path doesn't have to exist). Can be used with 'true' or 'false'.
	 </P
></LI
><LI
><P
>&#13;	     <TT
CLASS="literal"
>is_ascii</TT
> - matches only when a string property contain only ASCII characters. 
	     Can be used with 'true' or 'false'.
	 </P
></LI
><LI
><P
>&#13;	     <TT
CLASS="literal"
>compare_lt</TT
> - can be used on int, uint64, double and string properties to compare
	     with a constant. Matches when the given property is less than the given constant
	     using the default ordering.
	 </P
></LI
><LI
><P
>&#13;	     <TT
CLASS="literal"
>compare_le</TT
> - like <TT
CLASS="literal"
>compare_lt</TT
> but matches when less than or equal.
	 </P
></LI
><LI
><P
>&#13;	     <TT
CLASS="literal"
>compare_gt</TT
> - like <TT
CLASS="literal"
>compare_lt</TT
> but matches when greater than.
	 </P
></LI
><LI
><P
>&#13;	     <TT
CLASS="literal"
>compare_ge</TT
> - like <TT
CLASS="literal"
>compare_lt</TT
> but matches when greater than or equal.
	 </P
></LI
></UL
>

       The <TT
CLASS="literal"
>&#60;merge&#62;</TT
> 
       and <TT
CLASS="literal"
>&#60;append&#62;</TT
> directives all require 
       the <TT
CLASS="literal"
>type</TT
> attribute which specifies what to
       merge. The following values are supported

       <P
></P
><UL
><LI
><P
>&#13;	     <TT
CLASS="literal"
>string</TT
> - The value is copied to the property. For example
	     <TT
CLASS="literal"
>&#60;merge key="foo.bar" type="string"&#62;baz&#60;/merge&#62;</TT
>
	     will merge the value 'baz' into the property 'foo.bar'.	     
	 </P
></LI
><LI
><P
>&#13;	     <TT
CLASS="literal"
>bool</TT
> - Can merge the values 'true' or 'false'
	 </P
></LI
><LI
><P
>&#13;	     <TT
CLASS="literal"
>int</TT
> - Merges an integer
	 </P
></LI
><LI
><P
>&#13;	     <TT
CLASS="literal"
>uint64</TT
> - Merges an unsigned 64-bit integer
	 </P
></LI
><LI
><P
>&#13;	     <TT
CLASS="literal"
>double</TT
> - Merges a double precision floating point number
	 </P
></LI
><LI
><P
>&#13;	     <TT
CLASS="literal"
>copy_property</TT
> - Copies the value of a given property - supports paths with
	     direct and indirect UDI's. For example
	     <TT
CLASS="literal"
>&#60;merge key="foo.bar" type="copy_property"&#62;@info.parent:baz.bat&#60;/merge&#62;</TT
>
	     will merge the value of the property <TT
CLASS="literal"
>baz.bat</TT
> on the device object with the UDI from
	     the property <TT
CLASS="literal"
>info.parent</TT
> into the property <TT
CLASS="literal"
>foo.bar</TT
> on 
	     the device object being processed.
	 </P
></LI
></UL
>

       Device Information files are stored in the following standard hierachy with the following default
       top level directories:

       <P
></P
><UL
><LI
><P
>&#13;	     <TT
CLASS="literal"
>20freedesktop</TT
> - device information files included with the hal tarball
	 </P
></LI
><LI
><P
>&#13;	     <TT
CLASS="literal"
>30osvendor</TT
> - device information files supplied by the operating system vendor
	 </P
></LI
><LI
><P
>&#13;	     <TT
CLASS="literal"
>40oem</TT
> - device information files from the device manufacturer and 
	     installed from media accompanying the hardware
	 </P
></LI
><LI
><P
>&#13;	     <TT
CLASS="literal"
>90defaultpolicy</TT
> - Default policy determined by the operating system vendor and
	     possibly edited by the system administrator
	 </P
></LI
><LI
><P
>&#13;	     <TT
CLASS="literal"
>95userpolicy</TT
> - Policy rules for specific devices.
	 </P
></LI
></UL
>

       All device information files are matched for every hal device object.
      
    </P
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="fdi-facts"
>Facts about devices</A
></H2
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
NAME="fdi-example-mp3player"
>Example: MP3 player</A
></H3
><P
>&#13;	
	This device information file matches an USB Mass Storage
	based MP3 player by the matching on the USB vendor and
	product identifiers.
	
      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;	&#60;?xml version="1.0" encoding="ISO-8859-1"?&#62; &#60;!-- -*- SGML -*- --&#62; 

&#60;deviceinfo version="0.2"&#62;
  &#60;device&#62;
    &#60;match key="info.bus" string="usb"&#62;
      &#60;match key="usb.vendor_id" int="0x066f"&#62;
        &#60;match key="usb.product_id" int="0x8000"&#62;
          &#60;merge key="info.category" type="string"&#62;portable_audio_player&#60;/merge&#62;
          &#60;merge key="info.capabilities" type="string"&#62;portable_audio_player&#60;/merge&#62;
          &#60;merge key="portable_audio_player.access_method" type="string"&#62;storage&#60;/merge&#62;
          &#60;merge key="portable_audio_player.output_formats" type="string"&#62;audio/mpeg audio/x-ms-wma&#60;/merge&#62;
          &#60;merge key="portable_audio_player.input_formats" type="string"&#62;audio/x-wav&#60;/merge&#62;
        &#60;/match&#62;
      &#60;/match&#62;
    &#60;/match&#62;
  &#60;/device&#62;
&#60;/deviceinfo&#62;
      </PRE
></TD
></TR
></TABLE
><P
>&#13;	
	The final set of properties look like this:
	
      </P
><P
>&#13;	<IMG
SRC="hal-fdi-example2.png">
      </P
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="fdi-example-camera"
>Example: Digital Still Camera</A
></H3
><P
>&#13;	
	This device information file matches a Sony digital still camera
	by matching on the USB vendor and product identifers.
	
      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;	&#60;?xml version="1.0" encoding="ISO-8859-1"?&#62; &#60;!-- -*- SGML -*- --&#62; 

&#60;deviceinfo version="0.2"&#62;
  &#60;device&#62;
    &#60;match key="info.bus" string="usb"&#62;
      &#60;match key="usb.vendor_id" int="0x054c"&#62;
        &#60;match key="usb.product_id" int="0x0010"&#62;
          &#60;merge key="info.category" type="string"&#62;camera&#60;/merge&#62;
          &#60;merge key="info.capabilities" type="string"&#62;camera&#60;/merge&#62;
          &#60;merge key="camera.access_method" type="string"&#62;storage&#60;/merge&#62;
        &#60;/match&#62;
      &#60;/match&#62;
    &#60;/match&#62;
  &#60;/device&#62;
&#60;/deviceinfo&#62;
      </PRE
></TD
></TR
></TABLE
><P
>&#13;	
	The final set of properties look like this:
	
      </P
><P
>&#13;	<IMG
SRC="hal-fdi-example1.png">
      </P
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="fdi-example-6in1"
>Example: Card Reader</A
></H3
><P
>&#13;	
	This device information file matches a memory card reader with
	multiple storage ports that can be active at the same time.
	
      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;	&#60;?xml version="1.0" encoding="ISO-8859-1"?&#62; &#60;!-- -*- SGML -*- --&#62; 

&#60;deviceinfo version="0.2"&#62;
  &#60;device&#62;
    &#60;match key="info.bus" string="usb"&#62;
      &#60;match key="usb.vendor_id" int="0x0424"&#62;
        &#60;match key="usb.product_id" int="0x20fc"&#62;
          &#60;merge key="storage_lun0.drive_type" type="string"&#62;compact_flash&#60;/merge&#62;
          &#60;merge key="storage_lun1.drive_type" type="string"&#62;memory_stick&#60;/merge&#62;
          &#60;merge key="storage_lun2.drive_type" type="string"&#62;smart_media&#60;/merge&#62;
          &#60;merge key="storage_lun3.drive_type" type="string"&#62;sd_mmc&#60;/merge&#62;
        &#60;/match&#62;
      &#60;/match&#62;
    &#60;/match&#62;
  &#60;/device&#62;
&#60;/deviceinfo&#62;
      </PRE
></TD
></TR
></TABLE
><P
>&#13;	
	As described in the documentation for the
	<TT
CLASS="literal"
>storage.physical_device</TT
> property in <A
HREF="#device-properties-storage"
>the Section called <I
><TT
CLASS="literal"
>storage</TT
> namespace</I
> in the Chapter called <I
>Device Properties</I
></A
> this device information
	file export information about each storage port through the
	property <TT
CLASS="literal"
>storage.drive_type</TT
>. Thus, one
	of the four <TT
CLASS="literal"
>storage</TT
> devices has the
	following properties that are merged from the device object
	that the device information file targets:
	
      </P
><P
>&#13;	<IMG
SRC="hal-fdi-example3.png">
      </P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="fdi-policy"
>Policy settings for devices</A
></H2
><P
>&#13;	Policy settings specifies system specific settings that a
	system administrator associates with a device instance. In the
	context of hal, this can be expressed in terms of device
	properties merged on the device object in question. Default
	policy can also be merged on the root computer device object.
      </P
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="fdi-example-mountsetting"
>Storage Devices</A
></H3
><P
>&#13;
	Policy for storage devices is expressed in the 
	<TT
CLASS="literal"
>storage.policy.default</TT
>, 
	<TT
CLASS="literal"
>storage.policy</TT
> and
	<TT
CLASS="literal"
>volume.policy</TT
> namespaces, see
	<A
HREF="#properties-policy"
>the Section called <I
>Policy Properties</I
> in the Chapter called <I
>Device Properties</I
></A
> for details.

      </P
><P
>&#13;	The default policy for storage devices shipped with hal looks like this
      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;	&#60;?xml version="1.0" encoding="ISO-8859-1"?&#62; &#60;!-- -*- SGML -*- --&#62; 

&#60;deviceinfo version="0.2"&#62;

  &#60;!-- Default policies merged onto computer root object  --&#62;
  &#60;device&#62;
    &#60;match key="info.udi" string="/org/freedesktop/Hal/devices/computer"&#62;
      &#60;merge key="storage.policy.default.mount_root" type="string"&#62;/media&#60;/merge&#62;
      &#60;merge key="storage.policy.default.use_managed_keyword" type="bool"&#62;true&#60;/merge&#62;
      &#60;merge key="storage.policy.default.managed_keyword.primary" type="string"&#62;managed&#60;/merge&#62;
      &#60;merge key="storage.policy.default.managed_keyword.secondary" type="string"&#62;kudzu&#60;/merge&#62;
      &#60;merge key="storage.policy.default.mount_option.noauto" type="bool"&#62;true&#60;/merge&#62;
      &#60;merge key="storage.policy.default.mount_option.pamconsole" type="bool"&#62;true&#60;/merge&#62;
      &#60;merge key="storage.policy.default.mount_option.exec" type="bool"&#62;true&#60;/merge&#62;
    &#60;/match&#62;
  &#60;/device&#62;

  &#60;device&#62;
    &#60;!-- Whitelist bus types of storage devices we care about  --&#62;
    &#60;match key="info.category" string="storage"&#62;
      &#60;match key="storage.bus" string="usb"&#62;
	&#60;merge key="storage.policy.should_mount" type="bool"&#62;true&#60;/merge&#62;      
      &#60;/match&#62;
      &#60;match key="storage.bus" string="ide"&#62;
	&#60;merge key="storage.policy.should_mount" type="bool"&#62;true&#60;/merge&#62;
      &#60;/match&#62;
      &#60;match key="storage.bus" string="ieee1394"&#62;
	&#60;merge key="storage.policy.should_mount" type="bool"&#62;true&#60;/merge&#62;
      &#60;/match&#62;
      &#60;match key="storage.bus" string="sata"&#62;
	&#60;merge key="storage.policy.should_mount" type="bool"&#62;true&#60;/merge&#62;
      &#60;/match&#62;
      &#60;match key="storage.bus" string="platform"&#62;
	&#60;merge key="storage.policy.should_mount" type="bool"&#62;true&#60;/merge&#62;
      &#60;/match&#62;
    &#60;/match&#62;
    &#60;!-- Also add SCSI optical drives --&#62;
    &#60;match key="storage.bus" string="scsi"&#62;
      &#60;match key="storage.drive_type" string="cdrom"&#62;
        &#60;merge key="storage.policy.should_mount" type="bool"&#62;true&#60;/merge&#62;
      &#60;/match&#62;
    &#60;/match&#62;

    &#60;!-- Handle drives with non-partitioned media  --&#62;
    &#60;match key="storage.no_partitions_hint" bool="true"&#62;
      &#60;!-- optical drives --&#62;
      &#60;match key="storage.drive_type" string="cdrom"&#62;
	&#60;merge key="storage.policy.mount_filesystem" type="string"&#62;auto&#60;/merge&#62;
	&#60;merge key="storage.policy.desired_mount_point" type="string"&#62;cdrom&#60;/merge&#62;
	&#60;match key="storage.cdrom.cdr" bool="true"&#62;
	  &#60;merge key="storage.policy.desired_mount_point" type="string"&#62;cdrecorder&#60;/merge&#62;
	&#60;/match&#62;
	&#60;match key="storage.cdrom.cdrw" bool="true"&#62;
	  &#60;merge key="storage.policy.desired_mount_point" type="string"&#62;cdrecorder&#60;/merge&#62;
	&#60;/match&#62;
	&#60;match key="storage.cdrom.dvdplusr" bool="true"&#62;
	  &#60;merge key="storage.policy.desired_mount_point" type="string"&#62;cdrecorder&#60;/merge&#62;
	&#60;/match&#62;
	&#60;match key="storage.cdrom.dvdplusrw" bool="true"&#62;
	  &#60;merge key="storage.policy.desired_mount_point" type="string"&#62;cdrecorder&#60;/merge&#62;
	&#60;/match&#62;
	&#60;match key="storage.cdrom.dvdram" bool="true"&#62;
	  &#60;merge key="storage.policy.desired_mount_point" type="string"&#62;cdrecorder&#60;/merge&#62;
	&#60;/match&#62;
	&#60;match key="storage.cdrom.dvdr" bool="true"&#62;
	  &#60;merge key="storage.policy.desired_mount_point" type="string"&#62;cdrecorder&#60;/merge&#62;
	&#60;/match&#62;
	&#60;match key="storage.cdrom.dvdrw" bool="true"&#62;
	  &#60;merge key="storage.policy.desired_mount_point" type="string"&#62;cdrecorder&#60;/merge&#62;
	&#60;/match&#62;
	&#60;match key="/org/freedesktop/Hal/devices/computer:linux.is_selinux_enabled" bool="true"&#62;
	  &#60;merge key="storage.policy.mount_option.fscontext=system_u:object_r:removable_t" type="bool"&#62;true&#60;/merge&#62;
	&#60;/match&#62;
      &#60;/match&#62;

      &#60;!-- floppy drives --&#62;
      &#60;match key="storage.drive_type" string="floppy"&#62;
	&#60;merge key="storage.policy.mount_filesystem" type="string"&#62;auto&#60;/merge&#62;
	&#60;merge key="storage.policy.desired_mount_point" type="string"&#62;floppy&#60;/merge&#62;
	&#60;match key="/org/freedesktop/Hal/devices/computer:linux.is_selinux_enabled" bool="true"&#62;
	  &#60;merge key="storage.policy.mount_option.fscontext=system_u:object_r:removable_t" type="bool"&#62;true&#60;/merge&#62;
	&#60;/match&#62;
      &#60;/match&#62;

      &#60;!-- zip drives --&#62;
      &#60;match key="storage.drive_type" string="zip"&#62;
	&#60;merge key="storage.policy.mount_filesystem" type="string"&#62;auto&#60;/merge&#62;
	&#60;merge key="storage.policy.desired_mount_point" type="string"&#62;zip&#60;/merge&#62;
	&#60;match key="/org/freedesktop/Hal/devices/computer:linux.is_selinux_enabled" bool="true"&#62;
	  &#60;merge key="storage.policy.mount_option.fscontext=system_u:object_r:removable_t" type="bool"&#62;true&#60;/merge&#62;
	&#60;/match&#62;
      &#60;/match&#62;

      &#60;!-- jaz drives --&#62;
      &#60;match key="storage.drive_type" string="jaz"&#62;
	&#60;merge key="storage.policy.mount_filesystem" type="string"&#62;auto&#60;/merge&#62;
	&#60;merge key="storage.policy.desired_mount_point" type="string"&#62;jaz&#60;/merge&#62;
	&#60;match key="/org/freedesktop/Hal/devices/computer:linux.is_selinux_enabled" bool="true"&#62;
	  &#60;merge key="storage.policy.mount_option.fscontext=system_u:object_r:removable_t" type="bool"&#62;true&#60;/merge&#62;
	&#60;/match&#62;
      &#60;/match&#62;
    &#60;/match&#62;

    &#60;!-- Normal volumes; use volume label, uuid or drive_type --&#62;
    &#60;match key="block.is_volume" bool="true"&#62;
      &#60;match key="volume.fsusage" string="filesystem"&#62;
	&#60;!-- skip for drives with the no partitions hint (they are handled above) --&#62;
	&#60;match key="@block.storage_device:storage.no_partitions_hint" bool="false"&#62;

	  &#60;merge key="volume.policy.should_mount" type="bool"&#62;true&#60;/merge&#62;
	  &#60;merge key="volume.policy.mount_filesystem" type="copy_property"&#62;volume.fstype&#60;/merge&#62;
	  
	  &#60;!-- Fallback is '&#60;storage.bus&#62;', appended with 'disk', e.g. usbdisk,
	       idedisk, scsidisk etc. --&#62;
	  &#60;merge key="volume.policy.desired_mount_point" type="copy_property"&#62;@block.storage_device:storage.bus&#60;/merge&#62;
	  &#60;append key="volume.policy.desired_mount_point" type="string"&#62;disk&#60;/append&#62;

         &#60;!-- zip drives --&#62;
         &#60;match key="storage.drive_type" string="zip"&#62;
 	   &#60;merge key="storage.policy.desired_mount_point" type="string"&#62;zip&#60;/merge&#62;
         &#60;/match&#62;
	  
          &#60;!-- Best: If available use filesystem label --&#62;
          &#60;match key="volume.label" empty="false"&#62;
            &#60;!-- unless it's a path (e.g. /boot, /, /home etc) --&#62;
            &#60;match key="volume.label" is_absolute_path="false"&#62;
	      &#60;!-- and only if the label is ascii --&#62;
              &#60;match key="volume.label" is_ascii="true"&#62;
		&#60;merge key="volume.policy.desired_mount_point" type="copy_property"&#62;volume.label&#60;/merge&#62;
              &#60;/match&#62;
            &#60;/match&#62;
          &#60;/match&#62;
	  
	  &#60;!-- Should never mount Apple Bootstrap partitions (it would be
	       a security hole) - should use the bootable flag from the
	       Mac partition table instead --&#62;
	  &#60;match key="volume.fstype" string="hfs"&#62;
	    &#60;match key="volume.label" string="bootstrap"&#62;
	      &#60;merge key="volume.policy.should_mount" type="bool"&#62;false&#60;/merge&#62;
	    &#60;/match&#62;
	  &#60;/match&#62;
	  
	  &#60;!-- Use selinux mount options for hotpluggable and removable
	       volumes --&#62;
	  &#60;match key="/org/freedesktop/Hal/devices/computer:linux.is_selinux_enabled" bool="true"&#62;
	    &#60;match key="@block.storage_device:storage.hotpluggable" bool="true"&#62;
	      &#60;merge key="volume.policy.mount_option.fscontext=system_u:object_r:removable_t" type="bool"&#62;true&#60;/merge&#62;
	    &#60;/match&#62;
	    &#60;match key="@block.storage_device:storage.removable" bool="true"&#62;
	      &#60;merge key="volume.policy.mount_option.fscontext=system_u:object_r:removable_t" type="bool"&#62;true&#60;/merge&#62;
	    &#60;/match&#62;
	  &#60;/match&#62;

	  &#60;!-- Use noatime and sync options for all hotpluggable or removable
	       volumes smaller than 2GB --&#62;
	  &#60;match key="volume.size" compare_lt="2147483648"&#62;
	    &#60;match key="@block.storage_device:storage.hotpluggable" bool="true"&#62;
	      &#60;merge key="volume.policy.mount_option.sync" type="bool"&#62;true&#60;/merge&#62;
	      &#60;merge key="volume.policy.mount_option.noatime" type="bool"&#62;true&#60;/merge&#62;
	    &#60;/match&#62;
	    &#60;match key="@block.storage_device:storage.removable" bool="true"&#62;
	      &#60;merge key="volume.policy.mount_option.sync" type="bool"&#62;true&#60;/merge&#62;
	      &#60;merge key="volume.policy.mount_option.noatime" type="bool"&#62;true&#60;/merge&#62;
	    &#60;/match&#62;
	  &#60;/match&#62;

	  &#60;!-- Use UTF-8 charset for vfat --&#62;
	  &#60;match key="volume.fstype" string="vfat"&#62;
	    &#60;merge key="volume.policy.mount_option.iocharset=utf8" type="bool"&#62;true&#60;/merge&#62;
	  &#60;/match&#62;
	  
	  &#60;!-- whitelist of partition table id's, if from a msdos partition table --&#62;
	  &#60;match key="volume.partition.msdos_part_table_type" exists="true"&#62;
	    &#60;!-- Default to no mount and punch holes --&#62;
	    &#60;merge key="volume.policy.should_mount" type="bool"&#62;false&#60;/merge&#62;
	    &#60;!-- Linux --&#62;
	    &#60;match key="volume.partition.msdos_part_table_type" int="0x83"&#62;
	      &#60;merge key="volume.policy.should_mount" type="bool"&#62;true&#60;/merge&#62;
	    &#60;/match&#62;
	    &#60;!-- FAT12 --&#62;
	    &#60;match key="volume.partition.msdos_part_table_type" int="0x01"&#62;
	      &#60;merge key="volume.policy.should_mount" type="bool"&#62;true&#60;/merge&#62;
	    &#60;/match&#62;
	    &#60;!-- FAT16 &#60;32M --&#62;
	    &#60;match key="volume.partition.msdos_part_table_type" int="0x04"&#62;
	      &#60;merge key="volume.policy.should_mount" type="bool"&#62;true&#60;/merge&#62;
	    &#60;/match&#62;
	    &#60;!-- FAT16 --&#62;
	    &#60;match key="volume.partition.msdos_part_table_type" int="0x06"&#62;
	      &#60;merge key="volume.policy.should_mount" type="bool"&#62;true&#60;/merge&#62;
	    &#60;/match&#62;
	    &#60;!-- HPFS/NTFS --&#62;
	    &#60;match key="volume.partition.msdos_part_table_type" int="0x07"&#62;
	      &#60;merge key="volume.policy.should_mount" type="bool"&#62;true&#60;/merge&#62;
	    &#60;/match&#62;
	    &#60;!-- W95 FAT32 --&#62;
	    &#60;match key="volume.partition.msdos_part_table_type" int="0x0b"&#62;
	      &#60;merge key="volume.policy.should_mount" type="bool"&#62;true&#60;/merge&#62;
	    &#60;/match&#62;
	    &#60;!-- W95 FAT32 (LBA) --&#62;
	    &#60;match key="volume.partition.msdos_part_table_type" int="0x0c"&#62;
	      &#60;merge key="volume.policy.should_mount" type="bool"&#62;true&#60;/merge&#62;
	    &#60;/match&#62;
	    &#60;!-- W95 FAT16 (LBA) --&#62;
	    &#60;match key="volume.partition.msdos_part_table_type" int="0x0e"&#62;
	      &#60;merge key="volume.policy.should_mount" type="bool"&#62;true&#60;/merge&#62;
	    &#60;/match&#62;
	  &#60;/match&#62;	  
	&#60;/match&#62;
      &#60;/match&#62;
    &#60;/match&#62;
    
  &#60;/device&#62;

  &#60;!-- Dont want to mount non-hotpluggable fixed disks since ideraid
       detection isnt complete as hald wrongly detects e.g. partitions
       from some IDE RAID controllers --&#62;
  &#60;device&#62;
    &#60;match key="storage.hotpluggable" bool="false"&#62;
      &#60;match key="storage.removable" bool="false"&#62;
	&#60;merge key="storage.policy.should_mount" type="bool"&#62;false&#60;/merge&#62;
      &#60;/match&#62;
    &#60;/match&#62;
  &#60;/device&#62;

&#60;/deviceinfo&#62;
      </PRE
></TD
></TR
></TABLE
><P
>&#13;	and can be overridden by OS vendors to suit their purposes.
      </P
><P
>&#13;	Users can also customize their own rules; some examples follow	
      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;	&#60;?xml version="1.0" encoding="ISO-8859-1"?&#62; &#60;!-- -*- SGML -*- --&#62; 

&#60;deviceinfo version="0.2"&#62;

  &#60;!-- Example: Match volumes from an external USB harddisk enclosure by 
                matching on vendor and model. Use mount points 

  		    my_usbdisk_part_&#60;partition-number&#62;

		NB: some drives (ieee1394 based IIRC) even export the
		property storage.serial, the unique serial number of the
		disk which is a better match --&#62;
  &#60;device&#62;
    &#60;match key="block.is_volume" bool="true"&#62;
      &#60;match key="volume.fsusage" string="filesystem"&#62;
	&#60;match key="@block.storage_device:storage.vendor" string="ST360021"&#62;
	  &#60;match key="@block.storage_device:storage.model" string="A"&#62;
	    &#60;merge key="volume.policy.desired_mount_point" type="string"&#62;my_usbdisk_partition_&#60;/merge&#62;
	    &#60;append key="volume.policy.desired_mount_point" type="copy_property"&#62;volume.partition.number&#60;/append&#62;
	  &#60;/match&#62;
	&#60;/match&#62;
      &#60;/match&#62;
    &#60;/match&#62;
  &#60;/device&#62;

  &#60;!-- Example: Match a volume from an USB Storage Based mp3 player
                by the file system UUID and assign a mount point.

                NB: When reformatting the volume a new UUID will be
                used and this rule will have to be altered --&#62;
  &#60;device&#62;
    &#60;match key="block.is_volume" bool="true"&#62;
      &#60;match key="volume.fsusage" string="filesystem"&#62;
	&#60;match key="volume.uuid" string="4150-3F34"&#62;
	  &#60;merge key="volume.policy.desired_mount_point" type="string"&#62;my_mp3_player&#60;/merge&#62;
	&#60;/match&#62;
      &#60;/match&#62;
    &#60;/match&#62;
  &#60;/device&#62;

&#60;/deviceinfo&#62;
      </PRE
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="callouts"
></A
>Callouts</H1
><P
>&#13;
      Callouts are programs invoked when the device object list is
      modified or when a device changes. As such, callouts can be used
      to maintain system-wide policy (that may be specific to the
      particular OS) such as changing permissions on device nodes,
      updating the systemwide <TT
CLASS="literal"
>/etc/fstab</TT
> file or
      configuring the networking subsystem.
      
    </P
><P
>&#13;      
      There are three different classes of callouts. A callout
      involves sequentially invoking all executable programs in a
      given directory in alphabetic order.

    </P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN2099"
></A
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
CELLSPACING="0"
CELLPADDING="4"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
>Type</TH
><TH
>Description</TH
><TH
>Callout Directory</TH
><TH
>Positional Parameters</TH
></TR
></THEAD
><TBODY
><TR
><TD
>Device Add/Remove</TD
><TD
>&#13;	      When a new device object have been added, this callout
	      is invoked just after a device have entered the GDL
	      (global device list) but just before it is announced
	      through the D-BUS network API (the device isn't
	      announced until the last callout has finished).
	      When a device object is to be removed this callout is
	      invoked and the device isn't removed before the last
	      callout has finished.
	    </TD
><TD
><TT
CLASS="literal"
>/etc/hal/device.d</TT
></TD
><TD
><TT
CLASS="literal"
>add</TT
> or <TT
CLASS="literal"
>remove</TT
></TD
></TR
><TR
><TD
>Capability Add/Remove</TD
><TD
>&#13;	      Invoked when a capability have been added or removed.
	    </TD
><TD
><TT
CLASS="literal"
>/etc/hal/capability.d</TT
></TD
><TD
><TT
CLASS="literal"
>add</TT
> or <TT
CLASS="literal"
>remove</TT
></TD
></TR
><TR
><TD
>Property Change</TD
><TD
>&#13;	      Invoked when a device property have been added, removed
	      or is modified.
	    </TD
><TD
><TT
CLASS="literal"
>/etc/hal/property.d</TT
></TD
><TD
>&#13;	      <TT
CLASS="literal"
>add</TT
>, <TT
CLASS="literal"
>remove</TT
> or 
	      <TT
CLASS="literal"
>modify</TT
>
	    </TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
><P
>&#13;      
      All callouts execute in the same environment as which the HAL
      daemon was started. In addition, the UDI of the device object is
      exported in the environment variable <TT
CLASS="literal"
>UDI</TT
>. All
      properties of the device object are exported in the environment
      prefixed with <TT
CLASS="literal"
>HAL_</TT
>. The HAL daemon isn't
      suspended while callouts are executing. Thus, callouts can
      communicate with the HAL daemon using the D-BUS network
      API. Hence, one application of callouts is to merge or modify
      properties on a device object.

    </P
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="dbus-api"
></A
>D-BUS Network API</H1
><P
> 

      The HAL daemon is a system-wide process that keeps track of a
      number of device objects. It communicates with the operating
      system and intercepts hotplug events as devices are plugged in
      and removed.  The daemon is also responsible for providing
      services to applications that wants to locate devices and
      perform generic operations on them such as obtaining exclusive
      access.  Non-generic operations, such as obtaining pictures from
      a camera device, is outside the scope of the HAL daemon; see
      <A
HREF="#using-devices"
>the Chapter called <I
>Using devices</I
></A
> for more information.

      </P
><P
>&#13;
      HAL has the concept of device stores. When a device is detected
      it is placed in the TDL (temporary device list) and then properties
      are merged from several sources including device information files
      and possibly callouts. Eventually, the device transitions to the
      GDL (global device list) and first then it becomes ''visible'' for 
      desktop applications.

      </P
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="AEN2141"
>Interface org.freedesktop.Hal.Manager</A
></H2
><P
> 

      Using D-BUS terminology, the HAL daemon provides the D-BUS
      service <TT
CLASS="literal"
>org.freedesktop.Hal</TT
>. This service
      offers a D-BUS object at a well-known
      location <TT
CLASS="literal"
>/org/freedesktop/Hal/Manager</TT
>. This
      object offers a D-BUS
      interface, <TT
CLASS="literal"
>org.freedesktop.Hal.Manager</TT
>, for
      querying device objects with the following methods:
      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;# Return a list of all devices in the GDL
#
# @return                       List of UDI's
#
array{string} GetAllDevices()

# Determine if a device with a given Unique Device Id exists in the GDL
#
# @param  udi                   Device UDI, for example '/org/freedesktop/Hal/devices/pci_8086_7111'
# @return                       TRUE iff the device with the given UDI exists
#
bool DeviceExists(string udi)

# Find the set of devices in the GDL that has a given property matching
# a given value
#
# @param  key                   Key, for example 'block.fstype'
# @param  value                 Value, for example 'ext3'
# @return                       Array of UDI's, may be empty
#
array{string} FindDeviceStringMatch(string key, string value)

# Find the set of devices in the GDL that has a given capability
#
# @param  capability            Capability, for example 'volume'
# @return                       Array of UDI's, may be empty
#
array{string} FindDeviceByCapability(string capability)
  
</PRE
></TD
></TR
></TABLE
><P
>&#13;
      This object also emits the following signals on the
      <TT
CLASS="literal"
>/org/freedesktop/Hal/Manager</TT
> object on the
      <TT
CLASS="literal"
>org.freedesktop.Hal.Manager</TT
> interface that
      applications can subscribe to using D-BUS:

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;
# Notification that a new device have been added to the GDL
#
# @param  udi                   Unique Device Id
#
void DeviceAdded(string udi)

# Notification that a new device have been removed from the GDL. The
# application cannot use this UDI anymore.
#
# @param  udi                   Unique Device Id
#
void DeviceRemoved(string udi)

# Notification that a device in the GDL have got a new capability. Note that
# this is emitted even though the device already had the old capability
#
# @param  udi                   Unique Device Id
#
void NewCapability(string udi, string capability)

</PRE
></TD
></TR
></TABLE
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="AEN2152"
>Example</A
></H3
><P
>&#13;
      The following brief Python program demonstrates some of the API

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;  #!/usr/bin/python
 
import gtk
import dbus

def device_added(interface, signal_name, service, path, message):
    [udi] = message.get_args_list ()
    print 'Device %s was added'%udi

def device_removed(interface, signal_name, service, path, message):
    [udi] = message.get_args_list ()
    print 'Device %s was removed'%udi

 
bus = dbus.Bus (dbus.Bus.TYPE_SYSTEM)
hal_service = bus.get_service ('org.freedesktop.Hal')
hal_manager = hal_service.get_object ('/org/freedesktop/Hal/Manager',
				      'org.freedesktop.Hal.Manager')

devices = hal_manager.GetAllDevices ()
for d in devices:
    print 'Found device %s'%d

bus.add_signal_receiver (device_added,
			 'DeviceAdded',
			 'org.freedesktop.Hal.Manager',
			 'org.freedesktop.Hal',
			 '/org/freedesktop/Hal/Manager')
bus.add_signal_receiver (device_removed,
			 'DeviceRemoved',
			 'org.freedesktop.Hal.Manager',
			 'org.freedesktop.Hal',
			 '/org/freedesktop/Hal/Manager')
gtk.main()
</PRE
></TD
></TR
></TABLE
><P
>&#13;
      which gives the following output

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;Found device /org/freedesktop/Hal/devices/block_TORiSAN DVD-ROM DRD-U624-00000000000000000001-disc
Found device /org/freedesktop/Hal/devices/block_TORiSAN DVD-ROM DRD-U624-00000000000000000001
Found device /org/freedesktop/Hal/devices/block_37332a77-105e-4e76-8e99-27d3746e0531
Found device /org/freedesktop/Hal/devices/block_3_2
Found device /org/freedesktop/Hal/devices/block_LS-120 SLIM3 00 UHD Floppy-0208MBA00211
Found device /org/freedesktop/Hal/devices/block_IC25N020ATCS05-0-CLP225F2G3UR4A
Found device /org/freedesktop/Hal/devices/ide_1_1
Found device /org/freedesktop/Hal/devices/ide_0_0
Found device /org/freedesktop/Hal/devices/ide_1_0
Found device /org/freedesktop/Hal/devices/usbif_usb_0_0_206_-1_0000:00:07.2_0
Found device /org/freedesktop/Hal/devices/ide_host_0
Found device /org/freedesktop/Hal/devices/ide_host_1
Found device /org/freedesktop/Hal/devices/pci_104c_8400
Found device /org/freedesktop/Hal/devices/usb_0_0_206_-1_0000:00:07.2
Found device /org/freedesktop/Hal/devices/pci_1002_4c4d
Found device /org/freedesktop/Hal/devices/pci_125d_1978
Found device /org/freedesktop/Hal/devices/pci_8086_7111
Found device /org/freedesktop/Hal/devices/pci_104c_ac1c/0
Found device /org/freedesktop/Hal/devices/pci_8086_7112
Found device /org/freedesktop/Hal/devices/pci_8086_7110
Found device /org/freedesktop/Hal/devices/input_13_65
Found device /org/freedesktop/Hal/devices/pci_104c_ac1c
Found device /org/freedesktop/Hal/devices/pci_8086_7190
Found device /org/freedesktop/Hal/devices/input_13_64
Found device /org/freedesktop/Hal/devices/pci_8086_7113
Found device /org/freedesktop/Hal/devices/pci_8086_7191
Found device /org/freedesktop/Hal/devices/computer

(insert USB mouse)

Device /org/freedesktop/Hal/devices/usb_46d_c001_410_-1_noserial was added
Device /org/freedesktop/Hal/devices/usbif_usb_46d_c001_410_-1_noserial_0 was added

(remove USB mouse)

Device /org/freedesktop/Hal/devices/usb_46d_c001_410_-1_noserial was removed
Device /org/freedesktop/Hal/devices/usbif_usb_46d_c001_410_-1_noserial_0 was removed
</PRE
></TD
></TR
></TABLE
><P
>&#13;
      </P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="AEN2160"
>Interface org.freedesktop.Hal.Device</A
></H2
><P
>&#13;
      Applications use
      the <TT
CLASS="literal"
>org.freedesktop.Hal.Manager</TT
> interface to
      locate the device objects they are interested in. When a device
      object (which is really a D-BUS object, note that the UDI is the
      objects object_path) is obtained, the HAL daemon provides the
      <TT
CLASS="literal"
>org.freedesktop.Hal.Device</TT
> interface on the
      object denoted by the UDI. This interface has the following
      methods

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;
# Set property
#
# @param  key                   Property to set
# @param  value                 Value to set
# @raises                       org.freedesktop.Hal.(NoSuchDevice|TypeMismatch|PermissionDenied)
#
void SetProperty(string key, any value)
void SetPropertyString(string key, string value)
void SetPropertyInteger(string key, int32 value)
void SetPropertyBoolean(string key, bool value)
void SetPropertyDouble(string key, double value)

# Get property
#
# @param  key                   Property to get
# @return                       The value of the property
# @raises                       org.freedesktop.Hal.(NoSuchDevice|NoSuchProperty|TypeMismatch)
#
any GetProperty(string key)
string GetPropertyString(string key)
int32 GetPropertyInteger(string key)
bool GetPropertyBoolean(string key)
double GetPropertyDouble(string key)

# Get all properties
#
# @return                       Dictionary from key to value
# @raises                       org.freedesktop.Hal.NoSuchDevice
#
map{string, any} GetAllProperties()

  
# Remove a property
#
# @param  key                   Property to remove
# @raises                       org.freedesktop.Hal.(NoSuchDevice|NoSuchProperty|PermissionDenied)
#
void RemoveProperty(string key)

# Get the type of a property
#
# @param  key                   Property
# @return                       D-BUS type of property
# @raises                       org.freedesktop.Hal.(NoSuchDevice|NoSuchProperty)
#
int32 GetPropertyType(string key)

# Determine if a property exists
#
# @param  key                   Property
# @return                       TRUE iff the property exists
# @raises                       org.freedesktop.Hal.NoSuchDevice
#
bool PropertyExists(string key)

# Add a capability to a device. Note that this will trigger a NewCapability
# signal to all client applications subscribing to signals from the Manager
# interface.
#
# @param  capability            Capability, e.g. 'net.80211'
# @raises                       org.freedesktop.Hal.(NoSuchDevice|PermissionDenied)
#
void AddCapability(string capability)

# Determine if a device got a given capability
#
# @param  capability            Capability, e.g. 'storage.cdrom'
# @return                       TRUE iff the device got the given capability
# @raises                       org.freedesktop.Hal.NoSuchDevice
#
bool QueryCapability(string capability)

# Take an advisory lock on the device.
#
# @param  reason                A user-presentable reason why the device
#                               is locked.
# @raises                       org.freedesktop.Hal.NoSuchDevice,
#                               org.freedesktop.Hal.DeviceAlreadyLocked
#
void Lock(string reason)

# Release an advisory lock on the device.
#
# @raises                       org.freedesktop.Hal.NoSuchDevice,
#                               org.freedesktop.Hal.DeviceAlreadyLocked,
#                               org.freedesktop.Hal.PermissionDenied
#
void Unlock()
</PRE
></TD
></TR
></TABLE
><P
>&#13;
      The device objects also emits the following signals on the
      org.freedesktop.Hal interface that applications can subscribe to 
      using D-BUS

      </P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="programlisting"
>&#13;# Notification that property have been modified
#
# @param  key                   Property
# @param  added                 True iff the property have been added
# @param  removed               True iff the property have been removed
#
void PropertyModified(string key, bool added, bool removed)

# Notification that an event happened on the device has occured.
#
# Normally this is used to signal events that aren't or can't be expressed
# in properties, e.g. 'ProcessorOverheating' etc. 
#
# @param  condition             Name of condition
# @param  ...                   Dependent on the condition name
void Condition(string condition, ...)

</PRE
></TD
></TR
></TABLE
><P
>&#13;
      Note that D-BUS supports that applications can opt to receive
      signals for only a subset of the devices available.

      </P
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="enforcing-policy"
></A
>Enforcing Policy</H1
><P
> 

      Notwithstanding the fact that HAL avoids to enforce any policy,
      it is useful to have a minimal set of guidelines such that
      applications using HAL written for one operating system can
      easily run on another. This chapter contains recommendations
      about how to enforce policy to achieve that goal.

    </P
><DIV
CLASS="sect1"
><HR><H2
CLASS="sect1"
><A
NAME="enforcing-stor-vol"
>Storage Devices</A
></H2
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
NAME="stor-vol-policy"
>Policy for Volumes and Storage devices</A
></H3
><P
>&#13;	  The properties in the <TT
CLASS="literal"
>storage.policy</TT
>, 
	  <TT
CLASS="literal"
>volume.policy</TT
> and 
	  <TT
CLASS="literal"
>storage.policy.default</TT
> namespaces should
	  be the preferred way to determine how and if a filesystem
	  can be mounted. See <A
HREF="#properties-policy"
>the Section called <I
>Policy Properties</I
> in the Chapter called <I
>Device Properties</I
></A
>
	  for details.
	</P
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="enforcing-storage-fstab"
>File systems file</A
></H3
><P
>&#13;	  An operating system vendor should maintain the 
	  <TT
CLASS="literal"
>/etc/fstab</TT
> file through the HAL callout
	  mechanism such that device objects of capability
	  <TT
CLASS="literal"
>volume</TT
> and <TT
CLASS="literal"
>storage</TT
> has
	  a corresponding entry if applicable cf. 
	  <A
HREF="#stor-vol-policy"
>the Section called <I
>Policy for Volumes and Storage devices</I
></A
>.
	</P
><P
>&#13;	  The reasoning behind this is, among other things, to
	  maintain the invariant that <TT
CLASS="literal"
>/etc/fstab</TT
>
	  list all available filesystems. In addition
	  the <TT
CLASS="literal"
>mount(1)</TT
> program should enable users
	  without superuser privileges to mount filesystems mentioned
	  in the <TT
CLASS="literal"
>/etc/fstab</TT
> file as long as they
	  have the <TT
CLASS="literal"
>user</TT
> option set.
	</P
></DIV
><DIV
CLASS="sect2"
><HR><H3
CLASS="sect2"
><A
NAME="enforcing-storage-locking"
>Disabling policy agents</A
></H3
><P
>&#13;	  Policy agents like volume mounters should ignore when media
	  is inserted into a drive that is locked by another
	  application. Thus, CD burning applications should lock the
	  device to disable auto mounting or automatic start of the
	  users preferred CD burning application when respectively
	  non-blank rewritable or blank media is inserted.
	</P
></DIV
></DIV
></DIV
></DIV
></BODY
></HTML
>